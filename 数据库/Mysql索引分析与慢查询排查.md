# Mysql索引分析与慢查询排查

> https://tech.meituan.com/2014/06/30/mysql-index.html 重点文章  
>
> https://tech.meituan.com/2014/08/20/innodb-lock.html

## 索引原理

索引，就跟图书的目录一样，是为了快速查询。但在数据库场景中，所面临的情况更复杂，有更多的等值查询、范围查询等。  

另外，数据保存在磁盘上，为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。  

### 磁盘IO与预读

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到**。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。  

### 索引的数据结构

InnoDB采用B+树，每一个节点是一个磁盘块，每个磁盘块包括一些数据项和指针。  

当查找过程中设计某一个节点中的数据时，会把这一整个磁盘块读入内存，则为发生一次I/O。有了索引，在上百万的数据中查询只需要三次IO。  

### B+树的性质

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，**B+树是按照从左到右的顺序来建立搜索树的**。b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

## 慢查询优化

### 1. 建立索引的几大原则

1. **联合索引的最左前缀匹配原则**：在使用联合索引时，Mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如 a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到。a,b,d的顺序可以任意调整。

   * 如果有一个 2 列的索引 (a, b)，则已经对 (a)、(a, b) 上建立了索引；
   * 如果有一个 3 列索引 (a, b, c)，则已经对 (a)、(a, b)、(a, b, c) 上建立了索引；

2. **= 和 in 可以乱序**，比如a = 1 and b = 2 and c = 3 ，可以任意顺序建立(a,b,c)索引，mysql的查询优化器会帮你优化成索引可以识别的形式。

3. **尽量选择唯一度高的列作为前导列**

4. **索引列不能参与计算**

5. **应尽量避免在where子句中对字段进行null判断**

6. **尽量扩展索引，不要新建索引**

7. 当对索引中所有列通过"=" 或 “IN” 进行精确匹配时，**索引都可以被用到**。

8. `select * from LOL where a = 2 and b > 1000 and c='JJJ疾风剑豪'; `。对于前面这种类型的sql语句；mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配。在a、b走完索引后，c已经是无序了，所以c就没法走索引，优化器会认为还不如全表扫描c字段来的快。所以只使用了(a,b)两个索引，影响了执行效率。

   其实，这种情况我们只需要将索引从(a,b,c)改为(a,c,b)即可让三个字段都走索引

9. **在like语句中，如果通配符 % 不出现在开头**，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀，在 like “value%” 可以使用索引，但是 like “%value%” 违背了最左匹配原则，不会使用索引，走的是全表扫描。

## 查询优化神器——explain

```
mysql> EXPLAIN SELECT 1;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+
1 row in set, 1 warning (0.01 sec)
```

### 各列的大致作用

| 列名              | 描述                                                     |
| ----------------- | -------------------------------------------------------- |
| id                | 在一个大的查询语句中每个`SELECT`关键字都对应一个唯一的id |
| select_type       | `SELECT`关键字对应的那个查询的类型                       |
| table             | 表名                                                     |
| partitions        | 匹配的分区信息                                           |
| **type**          | 针对单表的访问方法                                       |
| **possible_keys** | 可能用到的索引                                           |
| **key**           | 实际上使用的索引                                         |
| key_len           | 实际使用到的索引长度                                     |
| ref               | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息   |
| rows              | 预估的需要读取的记录条数                                 |
| filtered          | 某个表经过搜索条件过滤后剩余记录条数的百分比             |
| Extra             | 一些额外的信息                                           |

在这里我们主要看的几列是possible_keys，keys，rows。

* possible_keys：是指MySQL在搜索表记录时可能使用哪个索引。
  　　如果这个字段的值是NULL，就表示没有索引被用到。
    　　这种情况下，就可以检查WHERE子句中哪些字段哪些字段适合增加索引以提高查询的性能。
    　　创建一下索引，然后再用explain 检查一下。
*  key：显示MySQL实际上要用的索引。
    　　当没有任何索引被用到的时候，这个字段的值就是NULL。
        　　想要让MySQL强行使用或者忽略在 possible_keys字段中的索引列表，可以在查询语句中使用关键字force index, use index或 ignore index。参考SELECT语法。
* rows：显示MySQL在表中进行查询时必须检查的行数。

### 索引没起作用的几种情况

* 使用LIKE关键字查询

  如果使用LIKE时，匹配字符串的第一个字符为“%”，则索引不会起作用。

* 使用多列索引的查询时

  没有满足最左前缀匹配

* 使用OR关键字的查询

  查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，查询中才会使用索引。否则，查询将不使用索引。

https://tech.meituan.com/2014/06/30/mysql-index.html

