# Redis

## 简单介绍Redis
* C语言开发的数据库
* 数据存在内存中，读写速度非常快，广泛运用于缓存
* 除缓存外，也经常用来做分布式锁、消息队列
* Redis提供了多种数据类型。另外还支持事务、持久化、Lua、多种集群方案

## 分布式缓存的常见技术选型
Redis和Memcached，一般常用Redis

## Redis和Memcached的比较
### 共同点：
1. 都基于内存，一般用作缓存
2. 都有过期策略
3. 两者性能都非常高

### 区别：
1. Redis支持**更丰富的数据类型**，而Memcached只支持最简单的K-V
2. Redis支持数据的**持久化**，可以将内存中的数据保持在磁盘上，**重启的时候再次加载使用**；而Memcached的数据只能存在内存中，挂掉就没了
3. Redis有**灾难恢复机制**，将混村中的数据持久化到磁盘上
4. Redis在服务器内存用完之后，**可以将不用的数据放到磁盘上**，但是Memcached在内存用完之后会直接报异常
5. Memcached没有原生的集群，需要依靠客户端往集群中分片写入数据；但是Redis支持**原生的cluster模式**  
6. Redis使用**单线程的IO多路复用模型**（Redis 6.0引入了多线程IO）；Memcached是多线程，非阻塞IO复用的网络模型
7. Redis支持**发布订阅模型，Lua脚本，事务**等功能；Memcached不支持。
8. Redis**同时使用了惰性删除和定期删除**；Memcached过期数据的删除策略只用了惰性删除

## 为什么要用缓存
### 高性能：

用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是**直接操作内存，所以速度相当快。**  

不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

### 高并发：
> QPS（Query Per Second）：服务器每秒可以执行的查询次数  


Mysql一般QPS大概在1w左右（4核8G），但是使用Redis缓存之后很容易到达10w+，甚至最高能达到30w+（单机，集群的话会更高）  

## Redis常用的数据结构及使用场景
### string
string数据结构式简单的key-value类型。虽然Redis是用C语言写的，但是Redis并没有直接使用C语言的字符串表示，而是自己构建了一种**SDS（simple dynamic string，简单动态字符串）**  

相比于C原生字符串，SDS不光可以保存文本数据还可保存二进制数据，并且获取字符串长度复杂度为O（1）（C的字符串为O（n））。另外，Redis的SDS API是安全的，不会造成缓冲区溢出  

**常用命令**：set，get，strlen，exists，dect，incr，setex等  
**应用场景**：一般常用在需要计数的场景，比如用户的访问次数，热点文章的点赞转发数量等等  
### list
list即是**链表**。链表易于插入、删除、灵活调整链表长度，但随机访问困难。C语言没有实现链表，所以Redis实现了自己的链表数据结构。Redis的list实现为**双向链表**，支持**反向查找核遍历**，更方便操作，不过带来部分额外的内存开销。  

**常用命令**：rpush，rpop，lpush，lpop，lrange，len等  

**应用场景**：发布与订阅或者说消息队列，慢查询  

### hash
hash类似于**JDK1.8之前的hashmap，内部实现差不多是数组+链表，不过Redis做了更多优化**  

hash是一个string类型的field和value的映射表，**特别适合用于存储对象**。  

**常用命令**：hset,hmset,hexists,hget,hgetall,hkeys,hvals  

**应用场景**：系统中对象数据的存储  

### set
set类似Java中的HashSet。Redis中的set是一种无序集合，当你需要存储一列数据，但不希望出现重复数据时，sety是一个很好的选择。并且set提供了判断某个成员是否在一个set内的重要接口，这个也是list没有提供的。可以基于set轻易实现**交集、并集、差集**的操作  

**常用命令**：sadd, spop, smember, sismember, scard, sinterstore, sunion等  

**应用场景**：需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景  

### sorted set
和set相比，sorted set增加了一个**权重参数score**，使得集合中的元素能够按照score进行有序排列。还可以通过score的范围来获取元素的列表。  

**常用命令**：zadd, zcard, zscore, zrange, zrevrange, zrem等  

**应用场景**：需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。  

### bitmap  
bitmap存储的时连续的二进制数字，通过bitmap，只需要一个bit位来表示某个元素对应的值或者状态，key就是对应元素本身。我们知道八个bit组成一个byte，所以bitmap本身会极大节省存储空间。  

**常用命令**：setbit, getbit, bitcount, bitop  

**应用场景**：适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。  

**关于以上数据结构的详细用法和使用场景，看这个https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/redis-all.md#1-%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-redis-%E5%91%97  **  

## Redis单线程模型详解
**Redis基于Reactor模式设计开发了自己的一套高效的事件处理模型**。（Netty的线程也基于Reactor模式，它真是高性能I/O的基石），这套事件处理模型对印度个是Redis中的文件事件处理器（file event handler）。由于文件事件处理器时单线程方式运行的，所以我们一般说Redis是单线程模型。  

**既然是单线程，怎么监听大量的客户端链接呢？**  

Redis通过**IO多路复用**来监听来自客户端的大量链连接，它会将感兴趣的事件及类型注册到内核中，并监听每个事件是否发生。  

**I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。**  

另外，Redis服务器是一个事件驱动程序，服务器需要处理两类事件：1. 文件事件 2. 时间事件  

我们接触多的是** 文件事件 ** （客户端进行读取写入等操作，涉及一系列网络通信）  

**可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：
* 多个 socket（客户端连接）
* IO 多路复用程序（支持多个客户端连接的关键）
* 文件事件分派器（将 socket 关联到相应的事件处理器）
* 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
**  

![redis事件处理器](./Pics/redis事件处理器.png)  

## Redis没有多线程吗？ 为什么不用多线程？

虽然说Redis是单线程模型，但是Redis在**4.0版本之后就加入了对多线程的支持**  

不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。**大体上，6.0之前主要还是单线程处理**  

**为什么6.0之前不使用多线程？**  

1. 单线程变成容易，并且易维护
2. Redis的性能瓶颈不在于CPU，主要在于内存和网络
3. 多线程会存在死锁、上下文切换等问题，甚至会影响性能 

## Redis 6.0 之后为什么引入多线程？
**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。  

Redis虽然引入了多线程，但只是在**网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行，所以不需要担心线程安全问题**  

## Redis给缓存设置过期时间有啥用 
1. 内存是有限的，如果所有数据一直存在内存中，会OOM
2. 另外可以帮助实现一些只需要在一段时间内生效的数据，比如短信验证码，或者用户登录的token  

## Redis是如何判断数据是否过期的？
Redis维持了一个**过期字典**，可以看作是hash表，保存数据过期的事件。过期字典的键指向Redis数据库中的某个key；值是一个longlong类型的正数，其中保存了过期时间（毫秒精度的UNIX时间戳）  

![redis过期时间](./Pics/redis过期时间.png)  

## 过期时间的删除策略？
**重要！自己造缓存轮子的时候需要格外考虑的东西**  

1. **惰性删除**：只会在取出key对数据进行过期检查，这样对CPU最友好，但是可能造成太多过期的key没有被删除  
2. **定期删除**：每隔一段时间抽取一批key执行删除过期key操作。并且，Redis底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。  

定期删除对内存更友好，惰性删除对CPU更友好，两者各有优点，所以**Redis采用了定期删除+惰性/懒汉式删除的方式**  

还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。**通过内存淘汰机制解决**

## Redis的内存淘汰机制
>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?

Redis提供8种数据淘汰策略
1. volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选**最近最少使用的数据**淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选**将要过期的数据**淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中**任意选择数据**淘汰
4. allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-eviction：**禁止驱逐数据**，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

4.0 版本后增加以下两种：  

7. volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选**最不经常使用（这里看的是频率）的数据**淘汰
8. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## LRU的实现

## Redis持久化机制（怎么保证 Redis 挂掉之后再重启数据可以进行恢复）

大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。  

Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。两种方法各有优点  

### 快照持久化 RDB
Redis 可以通过**创建快照来获得存储在内存里面的数据在某个时间点上的副本**。Redis 创建快照之后，可以对快照进行备份，**可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。**  

RDB是Redis**默认**的持久化方式，可以在配置文件中配置创建快照触发的条件

```
save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

```

### AOF（append-only file）持久化
AOF持久化的**实时性更好**，已成为**主流的持久化方案**，可以通过`appendonly yes`开启  

开启 AOF 持久化后**每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件**。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。

Redis可以配置三种不同的AOF方式：
```
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

为了兼顾数据和写入性能，可以考虑每秒同步一次。这样不会受到性能影响，而且系统崩溃，用户最多丢失一秒钟的数据。  

### 补充
#### Redis 4.0开始支持RDB和AOF的混合持久化

如果把混合持久化打开，**AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头**。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。  

#### AOF重写
AOF 重写可以**产生一个新的 AOF 文件**，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。

AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。

在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个** AOF 重写缓冲区**，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会**将重写缓冲区中的所有内容追加到新 AOF 文件的末尾**，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，**服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作**
  
  
## Redis事务
Redis可以通过**MULTI, EXEC, DISCARD, WATCH** 等命令来实现事务的功能  

使用 MULTI命令后可以输入多个命令。Redis 不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。  

Redis的事务与关系型数据库的ACID特性不同，Redis由于不支持roll back，因此**不满足原子性，也不满足持久性**  

Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。

**你可以将 Redis 中的事务就理解为 ：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。**  

## Redis哨兵

## 跳表 

## SDS


