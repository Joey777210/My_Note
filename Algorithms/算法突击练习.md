# 算法突击练习

## 动态规划

### 5. 最长回文子串

因为[i,j]的子串是否是回文串取决于两点：

1. s[i] == s[j] ?
2. [i + 1, j - 1]是回文串？

所以可以看出这里有动态规划的特点。  

开辟一个dp数组，记录子串是否是回文串。刷新过程按一列一列，一列内部按行刷新。**注意刷新顺序，因为dp有依赖关系，可以画一个矩阵手推一下试试**   



```
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len == 0) return ""; 
        
        // dp[i][j] = true 表示[i,j]闭区间范围内的字符串是回文串
        boolean[][] dp = new boolean[len][len];
        
        // for (int i = 0; i < len; i++) {
        //     dp[i][i] = true;
        // }
        char[] strings = s.toCharArray();
        
        int max = 0;
        int begin = 0, end = 0;
        // 从左到右，一列一列的刷新
        // 外层控制列
        for (int j = 0; j < len; j++) {
            // 从上到下
            // 内层控制行
            for (int i = 0; i <= j; i++) {
                if (strings[i] != strings[j]) {
                    continue;
                } else {
                    if (j - i < 2) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // if (i == j) {
                //     dp[i][j] = true;
                // } else if (j - i == 1) {
                //     dp[i][j] = strings[i] == strings[j];
                // } else {
                //     dp[i][j] = dp[i + 1][j - 1] && (strings[i] == strings[j]);
                // }

            
                // 记录结果
                if (dp[i][j] && j - i + 1 > max) {
                    max = j - i + 1;
                    end = j;
                    begin = i;
                }
            }
        }
        return s.substring(begin, end + 1);
    }
}
```

### 1143. 最长公共子序列

高频面试题  

text1[0,i]和text2[0,j]的公共子序列长度有两个条件演变来

1. text1[0, i - 1]和text2[0, j - 1]的公共子序列长度
2. text[i]是否等于text[j]。如果相等，则公共子序列长度是i - 1,j - 1长度子序列长度 + 1；如果不相等那么看看text1变长1和text2变长1分别会不会影响公共子序列的长度

建立dp数组，dp\[i\]\[j\] = 3表示表示text1的前i个字符和text2的前j个字符中公共子序列长度是3  

从上到下，从左到右更新。  



```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int len1 = text1.length();
        int len2 = text2.length();
        // dp[i][j] = 3 表示text1的前i个字符和text2的前j个字符中公共子序列长度是3
        int[][] dp = new int[len1 + 1][len2 + 1];
        
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```



### 53. 最大子序和

子数组[0,i]内，以nums[i]结尾的最大子序列和，取决于：nums[i] + 以i - 1结尾的最大子序列和，是否大于nums[i]，也就是前面的最大子序列和是否对当前的有贡献。  

建立dp数组，保存以i结尾的最大子序列和  

```
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 0) return 0;

        // dp[3] = 5表示nums数组的中以nums[3]结尾的最大和的连续子数组的最大和是5
        int[] dp = new int[nums.length];
        
        dp[0] = nums[0];
        int max = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = dp[i - 1] + nums[i] > nums[i] ? dp[i - 1] + nums[i] : nums[i];
            max = Math.max(max, dp[i]);
        }

        return max;
    }
}
```



### 300. 最长递增子序列

跟上一题一样，以i结尾的最长递增子序列，取决于前面的最长递增子序列对i位置结尾的最长递增子序列做出的贡献。  

需要两层循环，对于每一个位置，查询前面的最长递增子序列

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 记录以i结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];

        dp[0] = 1;
        int max = 1;

        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }    
            max = Math.max(max, dp[i]);
        }
        //System.out.println(Arrays.toString(dp));
        return max;
    }
}
```



### 120. 三角形最小路径和

一层一层路径搜索，每一层的状态由上一层变化来，所以用动态规划挺合适的。（最小路径也可以搜索）  

注意处理每层第一个和最后一个，只能由上一层的一个位置变化来，其他的位置都是由上一层两个位置中比较小的变化来的。  

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] dp = new int[triangle.get(triangle.size() - 1).size()];
        
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            List<Integer> cur = triangle.get(i);
            int[] tmp = new int[dp.length];
            for (int j = 0; j < cur.size(); j++) {
                if (j == 0) tmp[j] = dp[j] + cur.get(j);
                else if (j == cur.size() - 1) tmp[j] = dp[j - 1] + cur.get(j);
                else tmp[j] = Math.min(dp[j], dp[j - 1]) + cur.get(j);
            }
            dp = tmp;
        }
        //System.out.println(Arrays.toString(dp));
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < dp.length; i++) {
            min = Math.min(min, dp[i]);
        }
        return min;
    }
}
```



### 152. 乘积最大子数组

连续子数组乘积，每个位置结尾的连续子数组是由前一位置为结尾的连续子数组乘积的贡献决定的。  

**由于乘积有符号变换，所以需要记录前一个位置的最大值和最小值，以应对发生符号变换时的最大值比较**。另外由于当前位置只依赖前面一个位置，所以不需要开辟数组，只需要用变量记录前一个位置即可  

```
class Solution {
    public int maxProduct(int[] nums) {
        int max = nums[0];

        // curmin 记录以当前位置 - 1作为结尾的子数组的最小乘积，以计算对当前位置连续子数组乘积的贡献
        // curmax 记录以当前位置 - 1作为结尾的子数组的最大乘积，以计算对当前位置连续子数组乘积的贡献
        int curmin = nums[0], curmax = nums[0];


        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < 0) {
                // 如果当前数字是负的，那么最大和最小要对换
                int tmp = curmin;
                curmin = curmax;
                curmax = tmp;
            }

            curmin = Math.min(curmin * nums[i], nums[i]);
            curmax = Math.max(curmax * nums[i], nums[i]);
            max = Math.max(curmax, max);
        }
        return max;
    }
}
```



### 121. 买卖股票的最佳时机



## 回溯

### 39. 组合总和

DFS最简单的题型。顺序往后搜索，添加一个元素到list之后，就继续下一个元素（当前元素可以重复利用）。跳出回溯的依据是target被剪成0或者负的了。  

另外可以先把candidates排序，这样就可以剪枝。因为target减去一个数是负的，那么剪掉更大的数也是负的。  

```
class Solution {
    List<List<Integer>> res;
    List<Integer> list;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        list = new ArrayList<>();
        // 排序之后可以剪枝
        Arrays.sort(candidates);
        dfs(candidates, target, 0);
        return res;
    }

    private void dfs(int[] candidates, int target, int cur) {
        if (target < 0 || cur == candidates.length) {
            return;
        }

        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }

        for (int i = cur; i < candidates.length; i++) {
            // 剪枝
            if (target - candidates[i] < 0) break;

            list.add(candidates[i]);
            dfs(candidates, target - candidates[i], i);
            list.remove(list.size() - 1);
        }
    }
}
```



### 46. 全排列

经典回溯题。用一个used数组记录当前位置是否被使用过。  

```
class Solution {
    List<List<Integer>> res;
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) return res;

        used = new boolean[nums.length];

        dfs(nums, used, new ArrayList<Integer>());
        
        return res;
    }       

    private void dfs(int[] nums, boolean[] used, ArrayList<Integer> list) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }

            list.add(nums[i]);
            used[i] = true;
            dfs(nums, used, list);
            used[i] = false;
            list.remove(list.size() - 1);
        }
    }
}
```



### 47. 全排列 II

搜索，注意不重复，要进行剪枝。剪枝的具体细节在代码注释里

```
class Solution {

    List<List<Integer>> res;
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) return res;

        used = new boolean[nums.length];
        Arrays.sort(nums);
        dfs(nums, used, new ArrayList<Integer>());
        
        return res;
    }       

    private void dfs(int[] nums, boolean[] used, ArrayList<Integer> list) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            // 剪枝
            // 如果当前元素和前一个元素一样，并且前一个元素刚刚作为起点搜索过一次了，则剪枝
            // 这里!used[i - 1]的意义在于，如果前一个元素刚作为起点被搜索了一次，那么used[i - 1]一定会在搜索结束时解除掉
            // 另外一个角度看，如果used[i - 1] == true，则说明i - 1元素在当前这一支的搜索树上，到达当前i位置是从i - 1位置搜索来的，而不是for循环遍历来的。
            if ((i != 0 && nums[i] == nums[i - 1]) && !used[i - 1]) {
                continue;
            }

            
            list.add(nums[i]);
            used[i] = true;
            dfs(nums, used, list);
            used[i] = false;
            list.remove(list.size() - 1);
        }
    }

}
```



### 40. 组合总和 II

39题的变式。每个数字只能用一次 + 不能有重复组合  

排序后，涉及到两个剪枝：

1. 如果target - candidates[i] < 0那么剪掉后面所有的candidates
2. 剪掉重复的beginner。在for循环中，是在循环找开始元素；如果不能用两个数值一样的开始元素，要剪枝。这样剪不会剪掉在一个组合中用两个数值一样的元素，因为这两个数值一样的元素所处的回溯深度不一样，不是在同一层级上的开始节点。  

```
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        res = new ArrayList<>();

        if (candidates.length == 0) return res; 
        Arrays.sort(candidates);
        dfs(candidates, target, new ArrayList<Integer>(), 0);
        return res;
    }

    private void dfs(int[] candidates, int target, ArrayList<Integer> list, int cur) {
        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }
        
        if (target < 0) return;

        for (int i = cur; i < candidates.length; i++) {
            // 大剪枝
            if (target - candidates[i] < 0) break;
            // 小剪枝，这里i > cur是剪枝的精髓！！！！
            if (i > cur && candidates[i] == candidates[i - 1]) continue;

            list.add(candidates[i]);
            dfs(candidates, target - candidates[i], list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



### 216. 组合求和 III

没啥好说的，比上一题简单，回溯+剪枝

```
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum3(int k, int n) {
        res = new ArrayList<>();
                
        if (n > 81) return res;

        dfs(n, k, new ArrayList<Integer>(), 1);
        
        return res; 
    }

    private void dfs(int n, int k, ArrayList<Integer> list, int cur) {
        if (n == 0 && k == 0) {
            res.add(new ArrayList<>(list));
            return;
        }

        if (n < 0 || k <= 0) {
            return;
        }

        for (int i = cur; i < 10; i++) {
            if (n - i < 0) break;

            list.add(i);
            dfs(n - i, k - 1, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



### 78. 子集

比较简单，直接回溯即可

```
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> subsets(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) {
            res.add(new ArrayList<Integer>());
            return res;
        }

        Arrays.sort(nums);
        dfs(nums, new ArrayList<Integer>(), 0);
        return res;
    }

    private void dfs(int[] nums, ArrayList<Integer> list, int cur) {
        res.add(new ArrayList<>(list));       

        for (int i = cur; i < nums.length; i++) {
            if (i > cur && nums[i - 1] == nums[i]) {
                continue;
            }

            list.add(nums[i]);
            dfs(nums, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



### 90. 子集 II

跟40题的剪枝是类似的，利用i > cur剪掉重复的起点

```
class Solution {


    List<List<Integer>> res;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) {
            res.add(new ArrayList<Integer>());
            return res;
        }

        Arrays.sort(nums);
        dfs(nums, new ArrayList<Integer>(), 0);
        return res;
    }

    private void dfs(int[] nums, ArrayList<Integer> list, int cur) {
        res.add(new ArrayList<>(list));       

        for (int i = cur; i < nums.length; i++) {
            if (i > cur && nums[i - 1] == nums[i]) {
                continue;
            }

            list.add(nums[i]);
            dfs(nums, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



## 滑动窗口

### 283. 移动零

勉强算滑动窗口。维持一个非零窗口，开始的时候窗口大小是0.让一个指针扫描数组，碰到非零元素就放在窗口最后，然后窗口扩展。最后把窗口右边界之后的位置全部设置为0。  

```
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums.length <= 1) return;
        int ptr1 = 0;
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[ptr1++] = nums[i];
            }
        }

        for (int i = ptr1; i < nums.length; i++) {
            nums[i] = 0;
        }
        
    }
}
```



### 剑指offer 42. 连续子数组的最大和

#### 方法一：滑动窗口

让一个指针作为窗口右边界滑动，不断扩展窗口大小，另外一个常量cur记录当前窗口的最大子数组和。  

如果当前窗口的最大子数组和是负数，则说明他对下一个窗口的子数组和没有贡献，那么全部删掉，让cur = 0 。否则保留cur  

```
class Solution {
    public int maxSubArray(int[] nums) {
        int ptr2 = 0;
        int cur = 0;
        int max = Integer.MIN_VALUE;
        for (; ptr2 < nums.length; ptr2++) {
            cur += nums[ptr2];
            max = Math.max(max, cur);
            if (cur < 0) {
                cur = 0;
            }
        }
        return max;
    }
}
```



#### 方法二：动态规划

和滑动窗口是一样的思路，只不过是要记录一下子数组的和    

前面子数组的贡献如果大于零，则取之，否则取零

```
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int max = nums[0];
        for (int i = 1; i < nums.length; i++) {
            nums[i] += Math.max(nums[i - 1], 0);
            max = Math.max(max, nums[i]);
        }
        return max;
    }
}
```



### 剑指offer 57-II. 和为s的连续正整数序列

由于数组递增，那么窗口收缩即可。  

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int ptr1 = 0;
        int ptr2 = nums.length - 1;
        int sum = nums[ptr1] + nums[ptr2];

        while (ptr1 <= ptr2) {
            if (sum == target) return new int[]{nums[ptr1], nums[ptr2]};
            while (sum < target) {
                sum -= nums[ptr1];
                ptr1++;
                sum += nums[ptr1];
            }

            while (sum > target) {
                sum -= nums[ptr2];
                ptr2--;
                sum += nums[ptr2];
            }
        }
        return new int[2];
    }
}
```



### 159. 至多包含两个不同字符的最长字串

付费题

### 340. 至多包含K个不同字符的最长字串

付费题

### 1004. 最大连续1的个数 III

滑动窗口典型题。  

滑动窗口一般定义一个begin，一个end。end主动扩展，当由于一些条件制约无法扩展时，则收缩begin、  

```
class Solution {
    public int longestOnes(int[] A, int K) {
        int max = 0;
        int len = 0;
        int begin = 0;
        for (int end = 0; end < A.length; end++) {
            if (A[end] == 1) {
                len++;
            }

            if (A[end] == 0) {
                K--;
                len++;
                // 当K不够用了，就从开头收缩
                while (K < 0) {
                    if (A[begin] == 0) {
                        K++;
                    }
                    begin++;
                    len--;
                }
            }
            max = Math.max(max, len);
        }
        return max;
    }
}
```



### 424. 替换后的最长重复字符

滑动窗口。  

还是同样的，定义right和left。right主动向右滑动，滑动过程中，由于加进来了新的元素，记录一下新元素的数量  

定义histMax记录**历史窗口中出现数量最大的元素，并非当前窗口中出现数量最多的元素**，并且如果新元素数量大于了以前的最大数量元素，则更新hisMax。   

如果当前窗口长度过长，导致k次替换无法满足，则left收缩，**收缩过程中不需要更新histMax**  

```
class Solution {
    public int characterReplacement(String s, int k) {
        char[] chars = new char[26];
        int left = 0;
        int histMax = 0;
        char[] ss = s.toCharArray();
        int right = 0;
        for (; right < ss.length; right++) {
            chars[ss[right] - 'A']++;
            histMax = Math.max(histMax, chars[ss[right] - 'A']);

            while (right - left + 1 > histMax + k) {
                chars[ss[left] - 'A']--;
                left++;
            }
        }
        return s.length() - left;
    }
}
```



### 567. 字符串的排列

跟上一题类似的。定义right和left，right主动向右滑动。  

滑动过程中，记录新加入的元素，如果新加入的元素在s1中没有，或者数量不够了，那么收缩left，收缩的同时把原本减掉的s1中的元素还给s1。  

```
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] ss1 = new int[26];
        for (char c : s1.toCharArray()) {
            ss1[c - 'a']++;
        }
        int len = s1.length();
        int left = 0;
        for (int right = 0; right < s2.length(); right++) {
            // System.out.println(right + " " + left);
            char cur = s2.charAt(right);
            ss1[cur - 'a']--;
            // 新加入的元素在s1中没有，或者数量不够
            while (ss1[cur - 'a'] < 0 && left <= right) {
                ss1[s2.charAt(left) - 'a']++;
                left++;
            }
            if (right - left + 1 == len) {
                return true;
            }
        }
        return false;
    }
}
```



### 1100. 长度为K的无重复字符子串

付费题

### 1438.  绝对差不超过限制的最长连续子数组

滑动窗口。  

这题需要计算最大值和最小值的差是否在limit以内，则需要维护窗口内的最大值和最小值。  

使用最大值和最小值队列来维护。当最大值与最小值的差超过了limit，则需要收缩窗口，直到差值小于等于limit.  

```
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        // 用来记录窗口中的最小值
        Deque<Integer> minQueue = new ArrayDeque<>();
        // 用来记录窗口中的最大值
        Deque<Integer> maxQueue = new ArrayDeque<>();

        int left = 0;
        int max = 0;
        for (int right = 0; right < nums.length; right++) {
            while (!minQueue.isEmpty() && minQueue.getLast() > nums[right]) {
                minQueue.removeLast();
            }
            while (!maxQueue.isEmpty() && maxQueue.getLast() < nums[right]) {
                maxQueue.removeLast();
            }
            minQueue.addLast(nums[right]);
            maxQueue.addLast(nums[right]);

            while (!minQueue.isEmpty() && !maxQueue.isEmpty() && maxQueue.getFirst() - minQueue.getFirst() > limit) {
                if (nums[left] == minQueue.getFirst()) {
                    minQueue.removeFirst();
                }
                if (nums[left] == maxQueue.getFirst()) {
                    maxQueue.removeFirst();
                }
                left++;
            }
            max = Math.max(max, right - left + 1);
        }
        return max;
    }
}
```



### 480. 滑动窗口中位数

## 双指针法

### 26. 删除排序数组中的重复项
双指针，一个指针指向最前面非重复的数组部分，另一个指针遍历数组。遍历到没有出现过的元素时，把元素拷贝到前面非重复部分，并让第一个指针后移  

```
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;

        int ptr1 = 1;
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) continue;
            else {
                nums[ptr1++] = nums[i];
            }
        }
        return ptr1;
    }
}
```

### 209. 长度最小的子数组
双指针/滑动窗口。定义left，right，right主动扩展。扩展超过target时，收缩left，收缩过程中记录窗口长度。  

```
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        
        int minLen = Integer.MAX_VALUE;
        int left = 0;
        int curSum = 0;
        for (int right = 0; right < nums.length; right++) {
            curSum += nums[right];
            if(curSum >= target) {
                while (curSum >= target) {
                    minLen = Math.min(minLen, right - left + 1);
                    curSum -= nums[left];
                    left++;
                }
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

### 42. 接雨水
* 方法一：按行，一行一行统计。超时  

* 方法二：按列，遍历每一列，找到该列左右的最大高度，即可计算当前列能存多少水  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;

        for (int i = 1; i < height.length - 1; i++) {
            int leftHigh = 0;
            for (int j = 0; j < i; j++) {
                if (height[j] >= leftHigh) {
                    leftHigh = height[j];
                }
            }

            int rightHigh = 0;
            for (int j = height.length - 1; j > i; j--) {
                if (height[j] >= rightHigh) {
                    rightHigh = height[j];
                }
            }
            
            int min = Math.min(leftHigh, rightHigh);

            sum +=  min > height[i] ? min - height[i] : 0;
        }
        return sum;
    }
}
```

* **方法三：动态规划。**  

之前方法二中，每计算一列，都要遍历一遍数组，时间复杂度非常的低，我们可以采用动态规划，记录每一列的左右最高列。  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        int len = height.length;
        int[] maxLeft = new int[len];
        int[] maxRight = new int[len];

        // 先记录每一个位置左右的最大高度，时间复杂度降到O(n)
        for (int i = 1; i < len; i++) {
            maxLeft[i] = Math.max(height[i - 1], maxLeft[i - 1]);
        }
        for (int i = len - 2; i >= 0; i--) {
            maxRight[i] = Math.max(height[i + 1], maxRight[i + 1]);
        }

        for (int i = 1; i < len - 1; i++) {
            int min = Math.min(maxLeft[i], maxRight[i]);
            if (min > height[i]) {
                sum += min - height[i];
            }
        }
        return sum;
    }
}
```

* **方法四：双指针**  

前面的动态规划，用到了两个数组来记录左右最高的柱子。但我们可以发现，其实每个柱子计算的时候，都只用到了maxLeft[i]和maxRight[i]，所以我们是不是能用双指针来代替动态规划记录呢？   

定义左右最大的指针，也就是说**要找到刷新maxLeft和maxRight指针的时机**   

先看左边maxLeft的刷新时机：当height[i - 1] > maxLeft时，maxLeft就要刷新为height[i - 1]。否则就不刷新  

右边指针maxRight的刷新时机也是同理。但是这还是要向两个方向遍历才能找到maxRight。  

从上面的更新时机，我们可以看到，**更新的时机就是，当前发现，指针指向的柱子已经不是最高的了，则更新为当前发现最高的**  

我们定义left指针和right指针，分别向内扫，边扫边计算当前指针扫到柱子能接的水量。  

既然是两个指针扫描，那么什么时候从左往右扫描，什么时候从右往左扫描呢？  

**我们看动态规划方法中，我们每一列计算的时候，是取左右两侧最高柱子中较小的一个来计算接雨水的（木桶短板），那么也就是说，在height[left - 1]小于height[i  + 1]的时候，右边maxRight到底多高，刷不刷新，都没关系，因为只会取左边的。**  

**那么也就是说，当前扫到的左边柱子，小于右边目前扫到的柱子高度时，就不需要考虑右边柱子的收缩；同理，右边小于左边，就不需要考虑左边柱子的收缩。**  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        int len = height.length;
        int maxLeft = 0;
        int maxRight = 0;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // 左边的新柱子小，所以不需要考虑右边的，刷新maxLeft
            if (height[left] < height[right]) {
                if (height[left] > maxLeft) {
                    maxLeft = height[left];
                } else {
                    sum += maxLeft - height[left];
                }
                left++;
            } else {
                if (height[right] > maxRight) {
                    maxRight = height[right];
                } else {
                    sum += maxRight - height[right];
                }
                right--;
            }
        }
        return sum;
    }
}
```

* **方法五：单调栈**

**由于每一个柱子的列上存储的水，只由其左右比他高的柱子来确定，那么就可以用单调栈来存储柱子的递减序列，当遇到非递减的柱子时，就计算当前柱子和栈顶柱子可以界定多少水，把这些水添加到sum中**  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                int index = stack.pop();
                if (stack.isEmpty()) break;
                int distance = i - stack.peek() - 1;
                sum += (Math.min(height[i], height[stack.peek()]) - height[index]) * distance;
            }
            stack.push(i);
        }
        return sum;
    }
}
```

