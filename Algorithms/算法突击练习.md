# 算法突击练习

## 动态规划

### 5. 最长回文子串

因为[i,j]的子串是否是回文串取决于两点：

1. s[i] == s[j] ?
2. [i + 1, j - 1]是回文串？

所以可以看出这里有动态规划的特点。  

开辟一个dp数组，记录子串是否是回文串。刷新过程按一列一列，一列内部按行刷新。**注意刷新顺序，因为dp有依赖关系，可以画一个矩阵手推一下试试**   

```
class Solution {
    public String longestPalindrome(String s) {
        int len = s.length();
        if (len == 0) return ""; 
        
        // dp[i][j] = true 表示[i,j]闭区间范围内的字符串是回文串
        boolean[][] dp = new boolean[len][len];
        
        // for (int i = 0; i < len; i++) {
        //     dp[i][i] = true;
        // }
        char[] strings = s.toCharArray();
        
        int max = 0;
        int begin = 0, end = 0;
        // 从左到右，一列一列的刷新
        // 外层控制列
        for (int j = 0; j < len; j++) {
            // 从上到下
            // 内层控制行
            for (int i = 0; i <= j; i++) {
                if (strings[i] != strings[j]) {
                    continue;
                } else {
                    if (j - i < 2) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // if (i == j) {
                //     dp[i][j] = true;
                // } else if (j - i == 1) {
                //     dp[i][j] = strings[i] == strings[j];
                // } else {
                //     dp[i][j] = dp[i + 1][j - 1] && (strings[i] == strings[j]);
                // }

            
                // 记录结果
                if (dp[i][j] && j - i + 1 > max) {
                    max = j - i + 1;
                    end = j;
                    begin = i;
                }
            }
        }
        return s.substring(begin, end + 1);
    }
}
```

### 1143. 最长公共子序列

高频面试题  

text1[0,i]和text2[0,j]的公共子序列长度有两个条件演变来

1. text1[0, i - 1]和text2[0, j - 1]的公共子序列长度
2. text[i]是否等于text[j]。如果相等，则公共子序列长度是i - 1,j - 1长度子序列长度 + 1；如果不相等那么看看text1变长1和text2变长1分别会不会影响公共子序列的长度

建立dp数组，dp\[i\]\[j\] = 3表示表示text1的前i个字符和text2的前j个字符中公共子序列长度是3  

从上到下，从左到右更新。  



```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int len1 = text1.length();
        int len2 = text2.length();
        // dp[i][j] = 3 表示text1的前i个字符和text2的前j个字符中公共子序列长度是3
        int[][] dp = new int[len1 + 1][len2 + 1];
        
        for (int i = 1; i <= len1; i++) {
            for (int j = 1; j <= len2; j++) {
                if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```



### 53. 最大子序和

子数组[0,i]内，以nums[i]结尾的最大子序列和，取决于：nums[i] + 以i - 1结尾的最大子序列和，是否大于nums[i]，也就是前面的最大子序列和是否对当前的有贡献。  

建立dp数组，保存以i结尾的最大子序列和  

```
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 0) return 0;

        // dp[3] = 5表示nums数组的中以nums[3]结尾的最大和的连续子数组的最大和是5
        int[] dp = new int[nums.length];
        
        dp[0] = nums[0];
        int max = dp[0];
        for (int i = 1; i < nums.length; i++) {
            dp[i] = dp[i - 1] + nums[i] > nums[i] ? dp[i - 1] + nums[i] : nums[i];
            max = Math.max(max, dp[i]);
        }

        return max;
    }
}
```



### 300. 最长递增子序列

跟上一题一样，以i结尾的最长递增子序列，取决于前面的最长递增子序列对i位置结尾的最长递增子序列做出的贡献。  

需要两层循环，对于每一个位置，查询前面的最长递增子序列

```
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 记录以i结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];

        dp[0] = 1;
        int max = 1;

        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }    
            max = Math.max(max, dp[i]);
        }
        //System.out.println(Arrays.toString(dp));
        return max;
    }
}
```



### 120. 三角形最小路径和

一层一层路径搜索，每一层的状态由上一层变化来，所以用动态规划挺合适的。（最小路径也可以搜索）  

注意处理每层第一个和最后一个，只能由上一层的一个位置变化来，其他的位置都是由上一层两个位置中比较小的变化来的。  

```
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int[] dp = new int[triangle.get(triangle.size() - 1).size()];
        
        dp[0] = triangle.get(0).get(0);
        for (int i = 1; i < triangle.size(); i++) {
            List<Integer> cur = triangle.get(i);
            int[] tmp = new int[dp.length];
            for (int j = 0; j < cur.size(); j++) {
                if (j == 0) tmp[j] = dp[j] + cur.get(j);
                else if (j == cur.size() - 1) tmp[j] = dp[j - 1] + cur.get(j);
                else tmp[j] = Math.min(dp[j], dp[j - 1]) + cur.get(j);
            }
            dp = tmp;
        }
        //System.out.println(Arrays.toString(dp));
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < dp.length; i++) {
            min = Math.min(min, dp[i]);
        }
        return min;
    }
}
```



### 152. 乘积最大子数组

连续子数组乘积，每个位置结尾的连续子数组是由前一位置为结尾的连续子数组乘积的贡献决定的。  

**由于乘积有符号变换，所以需要记录前一个位置的最大值和最小值，以应对发生符号变换时的最大值比较**。另外由于当前位置只依赖前面一个位置，所以不需要开辟数组，只需要用变量记录前一个位置即可  

```
class Solution {
    public int maxProduct(int[] nums) {
        int max = nums[0];

        // curmin 记录以当前位置 - 1作为结尾的子数组的最小乘积，以计算对当前位置连续子数组乘积的贡献
        // curmax 记录以当前位置 - 1作为结尾的子数组的最大乘积，以计算对当前位置连续子数组乘积的贡献
        int curmin = nums[0], curmax = nums[0];


        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < 0) {
                // 如果当前数字是负的，那么最大和最小要对换
                int tmp = curmin;
                curmin = curmax;
                curmax = tmp;
            }

            curmin = Math.min(curmin * nums[i], nums[i]);
            curmax = Math.max(curmax * nums[i], nums[i]);
            max = Math.max(curmax, max);
        }
        return max;
    }
}
```



### 121. 买卖股票的最佳时机
* 方法一：一次遍历，遍历过程中一边记录前面的最小价格，一边记录可能的最大收益

```
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;

        for (int i = 0; i < prices.length; i++) {
            if (minPrice > prices[i]) {
                minPrice = prices[i];
            } 
            if (prices[i] - minPrice > maxProfit) {
                maxProfit = prices[i] - minPrice;
            }
        }
        return maxProfit;
    }
}
```

* 方法二：动态规划

```
class Solution {
    public int maxProfit(int[] prices) {
        // dp[i][1]表示第i天持有股票时，手上持有的现金
        // dp[i][0]表示第i天不持有股票时，手上持有的现金

        int[][] dp = new int[prices.length][2];
    
        dp[0][0] = 0;
        dp[0][1] = -prices[0];

        int res = 0;
        for (int i = 1; i < prices.length; i++) {
            // 当前持有股票，可能是今天买的，也可能是昨天买的，二者取最大
            // 注意，由于本题只允许交易一次，所以今天买入时，手中现金就是-prices[i]
            dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
            // 当前不持有股票可能是今天卖掉的，也可能是昨天卖掉的，二者取最大
            dp[i][0] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][0]);
        }
        return dp[dp.length - 1][0];
    }
}
```

### 122. 买卖股票的最佳时机 II
无限次买入，所以直接记录所有上升段的收益即可  

```
class Solution {
    public int maxProfit(int[] prices) {
        // 计算所有上升段即可
        int res = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1]) res += prices[i] - prices[i - 1];
        }
        return res;
    }
}
```

### 123. 买卖股票的最佳时机 III
当前的收益，取决于前一天的收益。  

创建一个dp数组，三个维度，分别表示第几天，当前是否持有，已经卖出了几次。  
```
class Solution {
    public int maxProfit(int[] prices) {
        if (prices.length == 0) return 0; 
        // 三个维度分别对应，第几天，当前是否持有，已经卖出了几次
        int[][][] dp = new int[prices.length][2][3];
        dp[0][0][0] = 0;
        dp[0][1][0] = -prices[0];
        dp[0][1][1] = -prices[0];
        int len = prices.length;
        // 第几天
        for (int i = 1; i < len; i++) {
            dp[i][0][0] = 0;
            // 当前不持有，且已经卖出一次。可能是今天卖的，也可能是之前已经卖掉了。
            dp[i][0][1] = Math.max(dp[i - 1][1][0] + prices[i], dp[i - 1][0][1]);
            // 当前不持有，且已经卖出两次。可能是今天卖的，也可能是之前已经卖掉了。
            dp[i][0][2] = Math.max(dp[i - 1][1][1] + prices[i], dp[i - 1][0][2]);    
            // 当前持有，可能是今天买的，也可能是之前买的
            dp[i][1][0] = Math.max(dp[i - 1][0][0] - prices[i], dp[i - 1][1][0]);
            // 当前持有，且卖出过一次。可能是今天买的，也可能是之前买的
            dp[i][1][1] = Math.max(dp[i - 1][0][1] - prices[i], dp[i - 1][1][1]);
            // 当前持有，且卖出过两次，不可能
            dp[i][1][2] = Integer.MIN_VALUE;
        }
        // 最大收益是，不买，买一次，和买两次之间取最大
        return Math.max(dp[len - 1][0][0], Math.max(dp[len - 1][0][1], dp[len - 1][0][2]));
    }
}
```

### 309. 最佳买卖股票时机含冷冻期

看注释

```
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        if (len == 0) return 0;

        // 第i天结束时的状态; 0 持有 1 不持有 2 冷冻期
        int[][] dp = new int[len][3]; 
        dp[0][0] = -prices[0];
        
        for (int i = 1; i < len; i++) {
            // 当前持有, 可能是前一天持有，可能是前一天不持有今天刚买的
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            // 当前不持有，且不在冷冻期，可能是前一天不持有，或者是前一天是冷冻期
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][2]);
            // 今天结束后进入冷冻期，则是今天刚卖掉的
            dp[i][2] = dp[i - 1][0] + prices[i];
        }
        return Math.max(dp[len - 1][1], dp[len - 1][2]);
    }
}
```

### 714. 买卖股票的最佳时机含手续费

看注释

```
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int len = prices.length;
        if (len == 0) return 0;

        // 第i天结束时；当天（0 不持有 1 持有）的最大收益
        int[][] dp = new int[len][2];
        dp[0][1] = -prices[0];
        for(int i = 1; i < len; i++) {
            // 当前天结束时不持有，可能是前一天就不持有，或者当天刚刚卖出
            // 定义卖出时扣除手续费
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee);
            // 当前天结束时持有，可能是前一天就持有，或者当天刚刚买入
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        }
        return dp[len - 1][0];
    }
}
```



### 70. 爬楼梯

dp数组长度n + 1的原因是从地面开始上，需要将地面设置为0

```
class Solution {
    public int climbStairs(int n) {
        if (n < 3) return n;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }
}
```

### 746. 使用最小花费爬楼梯

上楼梯，每上到一级台阶的开销都是从上一级台阶或者上两级台阶上来的开销之间取最小。由于可以选择从0或者1开始上，所以dp[0]和dp[1]都是0    

数组长度n + 1的原因是，要上到屋顶，所以要多一级  

```
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        if (n < 2) return 0;
        int[] dp = new int[n + 1];
        for (int i = 2; i < n + 1; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[n];
    }
}
```

### 64. 最小路径和

简单dp  

```
class Solution {
    public int minPathSum(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int[][] dp = new int[n][m];
        // 初始化第一行第一列
        for (int i = 0; i < n; i++) {
            if (i == 0) dp[i][0] = grid[i][0];
            else dp[i][0] = dp[i - 1][0] + grid[i][0];
        }

        for (int j = 0; j < m; j++) {
            if (j == 0) dp[0][j] = grid[0][j];
            else dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[n - 1][m - 1];
    }
}
```

### 118. 杨辉三角

倒也没啥好说的，根据前面的结果直接生成下一行就行  

```
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> res = new ArrayList<>();

        res.add(new ArrayList<>(){{add(1);}});
        for (int i = 1; i < numRows; i++) {
            List<Integer> cur = new ArrayList<>();
            List<Integer> pre = res.get(i - 1);

            cur.add(1);
            for (int j = 1; j < pre.size(); j++) {
                cur.add(pre.get(j - 1) + pre.get(j));
            }
            cur.add(1);
            res.add(cur);
        }
        return res;
    }
}
```

### 62. 不同路径

定义一个二维数组来dp

```
class Solution {
    public int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) {
            return 0;
        }

        int[][] dp = new int[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                    continue;
                }
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

由于每个位置只用了上和左两个位置，所以可以重复使用一个一维数组进行dp，来优化空间  

```
class Solution {
    public int uniquePaths(int m, int n) {
        if (m == 0 || n == 0) {
            return 0;
        }

        int[] dp = new int[n];
        Arrays.fill(dp, 1);

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[j] += dp[j - 1];
            }
        }
        return dp[n - 1];
    }
}
```

### 139. 单词拆分

dp[i]表示前i个元素能否被分割  

```
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> set = new HashSet<>();
        for (String sss : wordDict) {
            set.add(sss);
        }
        // 表示前i个字符组成的子串能否被分割，(0, i)能被分割，则dp[i]为true
        boolean[] dp = new boolean[s.length() + 1];        
        dp[0] = true;
        
        for (int i = 1; i <= s.length(); i++) {
            for (int j = i; j >= 0; j--) {
                if (set.contains(s.substring(j, i)) && dp[j]) {
                    dp[i] = true;
                    break;
                }
            }
        }
        // System.out.println(Arrays.toString(dp));
        return dp[s.length()];
    }
}
```





## 回溯

### 39. 组合总和

DFS最简单的题型。顺序往后搜索，添加一个元素到list之后，就继续下一个元素（当前元素可以重复利用）。跳出回溯的依据是target被剪成0或者负的了。  

另外可以先把candidates排序，这样就可以剪枝。因为target减去一个数是负的，那么剪掉更大的数也是负的。  

```
class Solution {
    List<List<Integer>> res;
    List<Integer> list;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<>();
        list = new ArrayList<>();
        // 排序之后可以剪枝
        Arrays.sort(candidates);
        dfs(candidates, target, 0);
        return res;
    }

    private void dfs(int[] candidates, int target, int cur) {
        if (target < 0 || cur == candidates.length) {
            return;
        }

        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }

        for (int i = cur; i < candidates.length; i++) {
            // 剪枝
            if (target - candidates[i] < 0) break;

            list.add(candidates[i]);
            dfs(candidates, target - candidates[i], i);
            list.remove(list.size() - 1);
        }
    }
}
```



### 46. 全排列

经典回溯题。用一个used数组记录当前位置是否被使用过。  

```
class Solution {
    List<List<Integer>> res;
    boolean[] used;
    public List<List<Integer>> permute(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) return res;

        used = new boolean[nums.length];

        dfs(nums, used, new ArrayList<Integer>());
        
        return res;
    }       

    private void dfs(int[] nums, boolean[] used, ArrayList<Integer> list) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }

            list.add(nums[i]);
            used[i] = true;
            dfs(nums, used, list);
            used[i] = false;
            list.remove(list.size() - 1);
        }
    }
}
```



### 47. 全排列 II

搜索，注意不重复，要进行剪枝。剪枝的具体细节在代码注释里

```
class Solution {

    List<List<Integer>> res;
    boolean[] used;
    public List<List<Integer>> permuteUnique(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) return res;

        used = new boolean[nums.length];
        Arrays.sort(nums);
        dfs(nums, used, new ArrayList<Integer>());
        
        return res;
    }       

    private void dfs(int[] nums, boolean[] used, ArrayList<Integer> list) {
        if (list.size() == nums.length) {
            res.add(new ArrayList<>(list));
            return;
        }

        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            // 剪枝
            // 如果当前元素和前一个元素一样，并且前一个元素刚刚作为起点搜索过一次了，则剪枝
            // 这里!used[i - 1]的意义在于，如果前一个元素刚作为起点被搜索了一次，那么used[i - 1]一定会在搜索结束时解除掉
            // 另外一个角度看，如果used[i - 1] == true，则说明i - 1元素在当前这一支的搜索树上，到达当前i位置是从i - 1位置搜索来的，而不是for循环遍历来的。
            if ((i != 0 && nums[i] == nums[i - 1]) && !used[i - 1]) {
                continue;
            }

            
            list.add(nums[i]);
            used[i] = true;
            dfs(nums, used, list);
            used[i] = false;
            list.remove(list.size() - 1);
        }
    }

}
```



### 40. 组合总和 II

39题的变式。每个数字只能用一次 + 不能有重复组合  

排序后，涉及到两个剪枝：

1. 如果target - candidates[i] < 0那么剪掉后面所有的candidates
2. 剪掉重复的beginner。在for循环中，是在循环找开始元素；如果不能用两个数值一样的开始元素，要剪枝。这样剪不会剪掉在一个组合中用两个数值一样的元素，因为这两个数值一样的元素所处的回溯深度不一样，不是在同一层级上的开始节点。  

```
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        res = new ArrayList<>();

        if (candidates.length == 0) return res; 
        Arrays.sort(candidates);
        dfs(candidates, target, new ArrayList<Integer>(), 0);
        return res;
    }

    private void dfs(int[] candidates, int target, ArrayList<Integer> list, int cur) {
        if (target == 0) {
            res.add(new ArrayList<>(list));
            return;
        }
        
        if (target < 0) return;

        for (int i = cur; i < candidates.length; i++) {
            // 大剪枝
            if (target - candidates[i] < 0) break;
            // 小剪枝，这里i > cur是剪枝的精髓！！！！
            if (i > cur && candidates[i] == candidates[i - 1]) continue;

            list.add(candidates[i]);
            dfs(candidates, target - candidates[i], list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



### 216. 组合求和 III

没啥好说的，比上一题简单，回溯+剪枝

```
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> combinationSum3(int k, int n) {
        res = new ArrayList<>();
                
        if (n > 81) return res;

        dfs(n, k, new ArrayList<Integer>(), 1);
        
        return res; 
    }

    private void dfs(int n, int k, ArrayList<Integer> list, int cur) {
        if (n == 0 && k == 0) {
            res.add(new ArrayList<>(list));
            return;
        }

        if (n < 0 || k <= 0) {
            return;
        }

        for (int i = cur; i < 10; i++) {
            if (n - i < 0) break;

            list.add(i);
            dfs(n - i, k - 1, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



### 78. 子集

比较简单，直接回溯即可

```
class Solution {
    List<List<Integer>> res;
    public List<List<Integer>> subsets(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) {
            res.add(new ArrayList<Integer>());
            return res;
        }

        Arrays.sort(nums);
        dfs(nums, new ArrayList<Integer>(), 0);
        return res;
    }

    private void dfs(int[] nums, ArrayList<Integer> list, int cur) {
        res.add(new ArrayList<>(list));       

        for (int i = cur; i < nums.length; i++) {
            if (i > cur && nums[i - 1] == nums[i]) {
                continue;
            }

            list.add(nums[i]);
            dfs(nums, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```



### 90. 子集 II

跟40题的剪枝是类似的，利用i > cur剪掉重复的起点

```
class Solution {


    List<List<Integer>> res;
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        res = new ArrayList<>();

        if (nums.length == 0) {
            res.add(new ArrayList<Integer>());
            return res;
        }

        Arrays.sort(nums);
        dfs(nums, new ArrayList<Integer>(), 0);
        return res;
    }

    private void dfs(int[] nums, ArrayList<Integer> list, int cur) {
        res.add(new ArrayList<>(list));       

        for (int i = cur; i < nums.length; i++) {
            if (i > cur && nums[i - 1] == nums[i]) {
                continue;
            }

            list.add(nums[i]);
            dfs(nums, list, i + 1);
            list.remove(list.size() - 1);
        }
    }
}
```

### 131. 分割回文串

记忆化回溯

```
class Solution {
    List<List<String>> res;
    List<String> list;
    boolean[][] memo;
    public List<List<String>> partition(String s) {
        res = new ArrayList<>();
        list = new ArrayList<>();
        // 记忆化数组，记录[i, j]是否是回文串
        memo = new boolean[s.length()][s.length()];
        // 找0到最后的回文串分割
        dfs(s, 0, s.length() - 1);
        return res;
    }

    private void dfs(String s, int left, int right) {
        // System.out.println(s + " left " + left + " right " + right);
        // 如果回文串能找到最后一个元素，则说明整个字符串有一个解
        if (left > right) {
            res.add(new ArrayList<>(list));
            return;
        }
        // 从左向右找回文串
        for (int i = left; i <= right; i++) {
            // 如果发现了一个前缀串是回文串
            if (memo[left][i] || isHuiWen(s, left, i)) {
                memo[left][i] = true;
                // 则记录这个串
                list.add(s.substring(left, i + 1));
                // 然后继续向右寻找
                dfs(s, i + 1, right);
                // 找完删除掉
                list.remove(list.size() - 1);
            }
        }
    }

    // 包含right
    private boolean isHuiWen(String s, int ptr1, int ptr2) {
        while (ptr1 < ptr2) {
            if (s.charAt(ptr2) != s.charAt(ptr1)) {
                return false;
            }
            ptr1++;
            ptr2--;
        }
        return true;
    }
}
```

### 77. 组合

回溯 + 剪枝

```
class Solution {
    List<List<Integer>> res;
    List<Integer> list;
    public List<List<Integer>> combine(int n, int k) {
        res = new ArrayList<>();
        if (n < k || k == 0) return res;
        list = new ArrayList<>();

        dfs(1, n, k);
        return res;
    }

    private void dfs(int begin, int n, int k) {
        if (list.size() == k) {
            res.add(new ArrayList<>(list));
            return;
        }
        // 注意这里剪枝，如果当前的i，后面的数字数量不足以拼成k长度的list，则直接剪枝
        for (int i = begin; i <= n - (k - list.size()) + 1; i++) {
            list.add(i);
            dfs(i + 1, n, k);
            list.remove(list.size() - 1);
        }
    }
}
```

### 93. 复原IP地址

剪枝

```
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        if (s.length() < 4 || s.length() > 12) {
            return res;
        }

        dfs(s, 0, new ArrayList<>());
        return res;
    }

    private void dfs(String s, int begin, ArrayList list) {
        // 剩余的字符串长度 > 还需要拼接的IP段最大长度，剪枝
        if (s.length() - begin > (4 - list.size()) * 3) {
            return;
        }

        if (list.size() == 4 && begin == s.length()) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < list.size(); i++) {
                sb.append(list.get(i));
                if (i != 3) {
                    sb.append('.');
                }
            }
            res.add(sb.toString());
            return;
        }

        for (int i = begin; i < begin + 3 && i < s.length(); i++) {
            // 如果当前位置以'0'开头，则剪掉0开头的多位数，如 '01'
            if (s.charAt(begin) == '0' && i > begin) break;
                if (Integer.parseInt(s.substring(begin, i + 1)) <= 255) {
                    list.add(s.substring(begin, i + 1));
                    dfs(s, i + 1, list);
                    list.remove(list.size() - 1);
                }
        }
    }
}
```

 ### 17. 电话号码的字母组合

```
class Solution {
    List<String> res = new ArrayList<>();
    Map<Character, String> map;

    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return res;
        }    
        char[] chs = digits.toCharArray();
        map = new HashMap<>(){{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};

        dfs(0, new ArrayList<Character>(), chs);
        return res;
    }

    private void dfs(int begin, ArrayList<Character> list, char[] chs) {
        if (list.size() == chs.length) {
            StringBuilder sb = new StringBuilder();
            for (char c : list) {
                sb.append(c);
            }
            res.add(sb.toString());
            return;
        }

        for (int i = begin; i < chs.length; i++) {
            String alpha = map.get(chs[i]);
            for (int j = 0; j < alpha.length(); j++) {
                list.add(alpha.charAt(j));
                dfs(i + 1, list, chs);
                list.remove(list.size() - 1);
            }
        }
    }
}
```

 

## 滑动窗口

### 283. 移动零

勉强算滑动窗口。维持一个非零窗口，开始的时候窗口大小是0.让一个指针扫描数组，碰到非零元素就放在窗口最后，然后窗口扩展。最后把窗口右边界之后的位置全部设置为0。  

```
class Solution {
    public void moveZeroes(int[] nums) {
        if (nums.length <= 1) return;
        int ptr1 = 0;
        
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[ptr1++] = nums[i];
            }
        }

        for (int i = ptr1; i < nums.length; i++) {
            nums[i] = 0;
        }
        
    }
}
```



### 剑指offer 42. 连续子数组的最大和

#### 方法一：滑动窗口

让一个指针作为窗口右边界滑动，不断扩展窗口大小，另外一个常量cur记录当前窗口的最大子数组和。  

如果当前窗口的最大子数组和是负数，则说明他对下一个窗口的子数组和没有贡献，那么全部删掉，让cur = 0 。否则保留cur  

```
class Solution {
    public int maxSubArray(int[] nums) {
        int ptr2 = 0;
        int cur = 0;
        int max = Integer.MIN_VALUE;
        for (; ptr2 < nums.length; ptr2++) {
            cur += nums[ptr2];
            max = Math.max(max, cur);
            if (cur < 0) {
                cur = 0;
            }
        }
        return max;
    }
}
```



#### 方法二：动态规划

和滑动窗口是一样的思路，只不过是要记录一下子数组的和    

前面子数组的贡献如果大于零，则取之，否则取零

```
class Solution {
    public int maxSubArray(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int max = nums[0];
        for (int i = 1; i < nums.length; i++) {
            nums[i] += Math.max(nums[i - 1], 0);
            max = Math.max(max, nums[i]);
        }
        return max;
    }
}
```



### 剑指offer 57-II. 和为s的连续正整数序列

由于数组递增，那么窗口收缩即可。  

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int ptr1 = 0;
        int ptr2 = nums.length - 1;
        int sum = nums[ptr1] + nums[ptr2];

        while (ptr1 <= ptr2) {
            if (sum == target) return new int[]{nums[ptr1], nums[ptr2]};
            while (sum < target) {
                sum -= nums[ptr1];
                ptr1++;
                sum += nums[ptr1];
            }

            while (sum > target) {
                sum -= nums[ptr2];
                ptr2--;
                sum += nums[ptr2];
            }
        }
        return new int[2];
    }
}
```



### 159. 至多包含两个不同字符的最长字串

付费题

### 340. 至多包含K个不同字符的最长字串

付费题

### 1004. 最大连续1的个数 III

滑动窗口典型题。  

滑动窗口一般定义一个begin，一个end。end主动扩展，当由于一些条件制约无法扩展时，则收缩begin、  

```
class Solution {
    public int longestOnes(int[] A, int K) {
        int max = 0;
        int len = 0;
        int begin = 0;
        for (int end = 0; end < A.length; end++) {
            if (A[end] == 1) {
                len++;
            }

            if (A[end] == 0) {
                K--;
                len++;
                // 当K不够用了，就从开头收缩
                while (K < 0) {
                    if (A[begin] == 0) {
                        K++;
                    }
                    begin++;
                    len--;
                }
            }
            max = Math.max(max, len);
        }
        return max;
    }
}
```



### 424. 替换后的最长重复字符

滑动窗口。  

还是同样的，定义right和left。right主动向右滑动，滑动过程中，由于加进来了新的元素，记录一下新元素的数量  

定义histMax记录**历史窗口中出现数量最大的元素，并非当前窗口中出现数量最多的元素**，并且如果新元素数量大于了以前的最大数量元素，则更新hisMax。   

如果当前窗口长度过长，导致k次替换无法满足，则left收缩，**收缩过程中不需要更新histMax**  

```
class Solution {
    public int characterReplacement(String s, int k) {
        char[] chars = new char[26];
        int left = 0;
        int histMax = 0;
        char[] ss = s.toCharArray();
        int right = 0;
        for (; right < ss.length; right++) {
            chars[ss[right] - 'A']++;
            histMax = Math.max(histMax, chars[ss[right] - 'A']);

            while (right - left + 1 > histMax + k) {
                chars[ss[left] - 'A']--;
                left++;
            }
        }
        return s.length() - left;
    }
}
```



### 567. 字符串的排列

跟上一题类似的。定义right和left，right主动向右滑动。  

滑动过程中，记录新加入的元素，如果新加入的元素在s1中没有，或者数量不够了，那么收缩left，收缩的同时把原本减掉的s1中的元素还给s1。  

```
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] ss1 = new int[26];
        for (char c : s1.toCharArray()) {
            ss1[c - 'a']++;
        }
        int len = s1.length();
        int left = 0;
        for (int right = 0; right < s2.length(); right++) {
            // System.out.println(right + " " + left);
            char cur = s2.charAt(right);
            ss1[cur - 'a']--;
            // 新加入的元素在s1中没有，或者数量不够
            while (ss1[cur - 'a'] < 0 && left <= right) {
                ss1[s2.charAt(left) - 'a']++;
                left++;
            }
            if (right - left + 1 == len) {
                return true;
            }
        }
        return false;
    }
}
```



### 1100. 长度为K的无重复字符子串

付费题

### 1438.  绝对差不超过限制的最长连续子数组

滑动窗口。  

这题需要计算最大值和最小值的差是否在limit以内，则需要维护窗口内的最大值和最小值。  

使用最大值和最小值队列来维护。当最大值与最小值的差超过了limit，则需要收缩窗口，直到差值小于等于limit.  

```
class Solution {
    public int longestSubarray(int[] nums, int limit) {
        // 用来记录窗口中的最小值
        Deque<Integer> minQueue = new ArrayDeque<>();
        // 用来记录窗口中的最大值
        Deque<Integer> maxQueue = new ArrayDeque<>();

        int left = 0;
        int max = 0;
        for (int right = 0; right < nums.length; right++) {
            while (!minQueue.isEmpty() && minQueue.getLast() > nums[right]) {
                minQueue.removeLast();
            }
            while (!maxQueue.isEmpty() && maxQueue.getLast() < nums[right]) {
                maxQueue.removeLast();
            }
            minQueue.addLast(nums[right]);
            maxQueue.addLast(nums[right]);

            while (!minQueue.isEmpty() && !maxQueue.isEmpty() && maxQueue.getFirst() - minQueue.getFirst() > limit) {
                if (nums[left] == minQueue.getFirst()) {
                    minQueue.removeFirst();
                }
                if (nums[left] == maxQueue.getFirst()) {
                    maxQueue.removeFirst();
                }
                left++;
            }
            max = Math.max(max, right - left + 1);
        }
        return max;
    }
}
```



### 480. 滑动窗口中位数

**这题太复杂了，后面再做**

### 239. 滑动窗口最大值

双端队列 + 滑动窗口  

```
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0) {
            return new int[0];
        }
        
        // 双向队列,记录窗口中的最大值
        Deque<Integer> queue = new ArrayDeque<>();
        int[] res = new int[nums.length - k + 1];

        int cur = 0;
        // 右边界主动向右滑动
        for (int i = 0; i < nums.length; i++) {
            if (queue.isEmpty() || nums[i] <= queue.getLast()) {
                queue.add(nums[i]);
            } else {
                while (!queue.isEmpty() && nums[i] > queue.getLast()) {
                    queue.removeLast();
                }
                queue.add(nums[i]);
            }

            // 收缩左边界
            if (i - k >= 0 && nums[i - k] == queue.getFirst()) {
                queue.removeFirst();
            }

            // 如果窗口长度已经扩展到k了，则可以开始记录窗口中的最大值了
            if (i - k + 1>= 0) res[cur++] = queue.getFirst();
        }
        return res;
    }
}
```

### 978. 最长湍流数组

* 自己写的滑动窗口，pre记录前值

```
class Solution {
    public int maxTurbulenceSize(int[] arr) {
        if (arr.length == 0) return 0;
        if (arr.length == 1) return 1;
        int res = 1;
        int left = 0;
        int curLen = 1;
        // pre 记录前一对的趋势。增则为1，减则为-1
        int pre = 1;

        for (int right = 1; right < arr.length; right++) {
            if (curLen == 1) {
                if (arr[right - 1] == arr[right]) continue;
                pre = arr[right - 1] < arr[right] ? 1 : -1;
                curLen++;
                res = Math.max(curLen, res);
                continue;
            }
            // System.out.println(res + " " + curLen + " " + left + " " + right + " " + pre);

            if ((arr[right - 1] < arr[right] && pre == -1) || (arr[right - 1] > arr[right] && pre == 1)) {
                curLen++;
                pre = pre == 1 ? -1 : 1;
                res = Math.max(curLen, res);
            } else {
                left = right - 1;
                curLen = 1;
                right--;
            }
        }
        return res;
    }
}
```

* 答案里学的滑动窗口

```
class Solution {
    public int maxTurbulenceSize(int[] arr) {
        if (arr.length < 2) {
            return arr.length;
        }
        int res = 1;
        int right = 0;
        int left = 0;
        while (right < arr.length - 1) {
            // System.out.println(left + " " + right + " " + res);
            if (left == right) {
                // 如果和后一个相等，则两个指针一起往前走
                if (arr[left] == arr[left + 1]) {
                    left++;
                }
                right++;
            } else {
                if ((arr[right] > arr[right - 1] && arr[right] > arr[right + 1])|| 
                     (arr[right] < arr[right - 1] && arr[right] < arr[right + 1])) {
                    right++;
                } else {
                    left = right;
                }
            }
            res = Math.max(res, right - left + 1);
        }

        return res;
    } 
}
```

### 1151. 最少交换次数来组合所有的1

贵宾题



### 1052. 爱生气的书店老板

```
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int X) {
        if (customers.length == 0) {
            return 0;
        }

        int left = 0;
        // 抑制情绪最多转化满意多少顾客
        int max = 0;
        // 记录当前窗口由于抑制情绪被转化为满意的顾客
        int cur = 0;
        // 记录原本就会满意的顾客
        int origin = 0;
        for (int right = 0; right < customers.length; right++) {
            if (grumpy[right] == 0) {
                origin += customers[right];
            } else {
                cur += customers[right];
            }
            max = Math.max(max, cur);
            if (right - left + 1 == X) {
                if (grumpy[left] == 1) {
                    cur -= customers[left];
                }
                left++;
            }
        }
        return origin + max;
    }
}
```

### 1658. 将 x 减到 0 的最小操作数

这个题转化比较有意思

```
class Solution {
    public int minOperations(int[] nums, int x) {
        // 找两端的和等于x的，相当于找一个中间的连续子数组，使得nums整个数组的和sum，减去连续子数组的和，等于x
        // 也就是将两端dfs的题，转化为了滑动窗口找目标和的最长连续子数组的题
        int max = -1;
        int left = 0;
        int sum = Arrays.stream(nums).sum();
        int curSum = 0;
        for (int right = 0; right < nums.length; right++) {
            curSum += nums[right];
            
            while (curSum > sum - x && left < nums.length) {
                curSum -= nums[left++];
            }
            if (curSum == sum - x) {
                max = Math.max(right - left + 1, max);
            }
        }
        return max == -1 ? -1 : nums.length - max;
    }
}
```



## 双指针法

### 26. 删除排序数组中的重复项
双指针，一个指针指向最前面非重复的数组部分，另一个指针遍历数组。遍历到没有出现过的元素时，把元素拷贝到前面非重复部分，并让第一个指针后移  

```
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;

        int ptr1 = 1;
        
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i - 1]) continue;
            else {
                nums[ptr1++] = nums[i];
            }
        }
        return ptr1;
    }
}
```

### 209. 长度最小的子数组
双指针/滑动窗口。定义left，right，right主动扩展。扩展超过target时，收缩left，收缩过程中记录窗口长度。  

```
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        
        int minLen = Integer.MAX_VALUE;
        int left = 0;
        int curSum = 0;
        for (int right = 0; right < nums.length; right++) {
            curSum += nums[right];
            if(curSum >= target) {
                while (curSum >= target) {
                    minLen = Math.min(minLen, right - left + 1);
                    curSum -= nums[left];
                    left++;
                }
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```

### 42. 接雨水
* 方法一：按行，一行一行统计。超时  

* 方法二：按列，遍历每一列，找到该列左右的最大高度，即可计算当前列能存多少水  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;

        for (int i = 1; i < height.length - 1; i++) {
            int leftHigh = 0;
            for (int j = 0; j < i; j++) {
                if (height[j] >= leftHigh) {
                    leftHigh = height[j];
                }
            }

            int rightHigh = 0;
            for (int j = height.length - 1; j > i; j--) {
                if (height[j] >= rightHigh) {
                    rightHigh = height[j];
                }
            }
            
            int min = Math.min(leftHigh, rightHigh);

            sum +=  min > height[i] ? min - height[i] : 0;
        }
        return sum;
    }
}
```

* **方法三：动态规划。**  

之前方法二中，每计算一列，都要遍历一遍数组，时间复杂度非常的低，我们可以采用动态规划，记录每一列的左右最高列。  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        int len = height.length;
        int[] maxLeft = new int[len];
        int[] maxRight = new int[len];

        // 先记录每一个位置左右的最大高度，时间复杂度降到O(n)
        for (int i = 1; i < len; i++) {
            maxLeft[i] = Math.max(height[i - 1], maxLeft[i - 1]);
        }
        for (int i = len - 2; i >= 0; i--) {
            maxRight[i] = Math.max(height[i + 1], maxRight[i + 1]);
        }

        for (int i = 1; i < len - 1; i++) {
            int min = Math.min(maxLeft[i], maxRight[i]);
            if (min > height[i]) {
                sum += min - height[i];
            }
        }
        return sum;
    }
}
```

* **方法四：双指针**  

前面的动态规划，用到了两个数组来记录左右最高的柱子。但我们可以发现，其实每个柱子计算的时候，都只用到了maxLeft[i]和maxRight[i]，所以我们是不是能用双指针来代替动态规划记录呢？   

定义左右最大的指针，也就是说**要找到刷新maxLeft和maxRight指针的时机**   

先看左边maxLeft的刷新时机：当height[i - 1] > maxLeft时，maxLeft就要刷新为height[i - 1]。否则就不刷新  

右边指针maxRight的刷新时机也是同理。但是这还是要向两个方向遍历才能找到maxRight。  

从上面的更新时机，我们可以看到，**更新的时机就是，当前发现，指针指向的柱子已经不是最高的了，则更新为当前发现最高的**  

我们定义left指针和right指针，分别向内扫，边扫边计算当前指针扫到柱子能接的水量。  

既然是两个指针扫描，那么什么时候从左往右扫描，什么时候从右往左扫描呢？  

**我们看动态规划方法中，我们每一列计算的时候，是取左右两侧最高柱子中较小的一个来计算接雨水的（木桶短板），那么也就是说，在height[left - 1]小于height[i  + 1]的时候，右边maxRight到底多高，刷不刷新，都没关系，因为只会取左边的。**  

**那么也就是说，当前扫到的左边柱子，小于右边目前扫到的柱子高度时，就不需要考虑右边柱子的收缩；同理，右边小于左边，就不需要考虑左边柱子的收缩。**  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        int len = height.length;
        int maxLeft = 0;
        int maxRight = 0;
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // 左边的新柱子小，所以不需要考虑右边的，刷新maxLeft
            if (height[left] < height[right]) {
                if (height[left] > maxLeft) {
                    maxLeft = height[left];
                } else {
                    sum += maxLeft - height[left];
                }
                left++;
            } else {
                if (height[right] > maxRight) {
                    maxRight = height[right];
                } else {
                    sum += maxRight - height[right];
                }
                right--;
            }
        }
        return sum;
    }
}
```

* **方法五：单调栈**

**由于每一个柱子的列上存储的水，只由其左右比他高的柱子来确定，那么就可以用单调栈来存储柱子的递减序列，当遇到非递减的柱子时，就计算当前柱子和栈顶柱子可以界定多少水，把这些水添加到sum中**  

```
class Solution {
    public int trap(int[] height) {
        int sum = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int i = 0; i < height.length; i++) {
            while (!stack.isEmpty() && height[stack.peek()] < height[i]) {
                int index = stack.pop();
                if (stack.isEmpty()) break;
                int distance = i - stack.peek() - 1;
                sum += (Math.min(height[i], height[stack.peek()]) - height[index]) * distance;
            }
            stack.push(i);
        }
        return sum;
    }
}
```

### 76. 最小覆盖子串
滑动窗口，定义left和right。另外定义一个哈希表，先存进去t中所有字符和数量。还定义了一个count，用来记录**t中的字符还有多少个没被匹配**。  

right主动扩张，碰到t中存在的字符就把哈希表对应的计数减 1，另外刷新count。count--的时机要注意，并不是碰到t中元素就减，而是哈希表中的元素计数大于0才减，也就是t中这个元素还没被消耗完的时候，count--。  

当count == 0时，则完成了一次结果检索，更新一下minLen，更新一下对应的res字符串。  

然后就要开始收缩left，收缩left有以下几个条件：
1. left小于等于right
2. 收缩到**刚好t中的元素没有被子串完全覆盖**
3. 满足条件2之后，还要看看left当前指向的元素是不是t中包含的元素，如果不是，也直接丢弃
4. 满足条件2，3之后，另外再看看当前left指向的元素，是不是对于t来说**过多了**，也就是哈希表中元素计数是不是小于零了，如果是，left指向的元素也直接丢弃

刷新left过程中也要刷新count，count增加的时机和减少的时机一样，只有计数大于等于零才能增加。  

```
class Solution {
    public String minWindow(String s, String t) {
        char[] ts = t.toCharArray();
        HashMap<Character, Integer> map = new HashMap<>();
        int count = 0;
        for (char c : ts) {
            map.put(c, map.getOrDefault(c, 0) + 1);
            count++;
        }

        char[] ss = s.toCharArray();
        int left = 0;
        int minLen = Integer.MAX_VALUE;
        String res = "";
        for (int right = 0; right < ss.length; right++) {
            if (map.containsKey(ss[right])) {
                if (map.get(ss[right]) > 0) {
                    count--;
                }
                map.put(ss[right], map.get(ss[right]) - 1);
            }

            if (count == 0) {
                if (minLen > right - left + 1) {
                    minLen = right - left + 1;
                    res = s.substring(left, right + 1);
                }
            }

            while (left <= right && (count == 0 || !map.containsKey(ss[left]) || map.get(ss[left]) < 0)) {
                if (map.containsKey(ss[left])) {
                    if (map.get(ss[left]) >= 0) {
                        count++;
                    }
                    map.put(ss[left], map.get(ss[left]) + 1);
                }
                left++;
            }
        }
        return res;
    }
}
```

### 面试题 10.01 合并排序的数组
从后往前双指针   

```
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int ptr1 = m - 1;
        int ptr2 = n - 1;
        int ptr = A.length - 1;

        while (ptr1 >= 0 && ptr2 >= 0) {
            if (A[ptr1] > B[ptr2]) {
                A[ptr] = A[ptr1--];
            } else {
                A[ptr] = B[ptr2--];
            }
            ptr--;
        }

        while (ptr1 >= 0) {
            A[ptr--] = A[ptr1--];
        }

        while (ptr2 >= 0) {
            A[ptr--] = B[ptr2--];
        }
        
    }
}
```

### 344. 反转字符串
头尾指针交换字符，直到指针碰撞
```
class Solution {
    public void reverseString(char[] s) {
        if (s.length < 2) {
            return;
        }
        char tmp;
        int head = 0, tail = s.length - 1;
        while (head < tail) {
            tmp = s[head];
            s[head] = s[tail];
            s[tail] = tmp;
            head++;
            tail--;
        }
    }
}
```

### 487. 最大连续1的个数 II

付费题

### 845. 数组中的最长山脉

用两个变量increasing = 0, decreasing = 0，记录每次寻找的上升段和下降段。   

```
class Solution {
    public int longestMountain(int[] arr) {
        // 山脉条件：长度大于等于3，先递增后递减
        int max = 0;
        int i = 1;
        while (i < arr.length) {
            int increasing = 0, decreasing = 0;

            while (i < arr.length && arr[i] > arr[i - 1]) {
                increasing++;
                i++;
            }
            while (i < arr.length && arr[i] < arr[i - 1]) {
                decreasing++;
                i++;
            }

            if (increasing > 0 && decreasing > 0) {
                max = Math.max(max, increasing + decreasing + 1);
            }

            while (i < arr.length && arr[i] == arr[i - 1]) {
                i++;
            }
        }
        return max;    
    }
}
```



## 贪心

### 1024. 视频拼接

```
class Solution {
    public int videoStitching(int[][] clips, int T) {
        // 贪心,首先找到从每个位置出发,能走到的最远位置
        int[] maxn = new int[T];
        for (int[] clip : clips) {
            if (clip[0] < T) {
                maxn[clip[0]] = Math.max(clip[1], maxn[clip[0]]);
            }
        }

        int res = 0;
        // 记录当前已经覆盖到的最远位置
        int curMax = 0;
        // 上一个被采用的子区间，能覆盖到的最远位置
        int preMax = 0;
        for (int i = 0; i < T; i++) {
            curMax = Math.max(curMax, maxn[i]);
            // i == curMax, 说明往前走不下去了，无法覆盖
            if (i == curMax) {
                return -1;
            }    
            // 如果上一个子区间用完了，则启用一个新的子区间，这个子区间的右边界是curMax
            if (i == preMax) {
                preMax = curMax;
                res++;
            }
        }
        return res;
    }
}
```

### 861. 翻转矩阵后的得分

```
class Solution {
    public int matrixScore(int[][] A) {
        if (A.length == 0 || A[0].length == 0) return 0;

        // 反转每一行，使最高位为1
        for (int i = 0; i < A.length; i++) {
            if (A[i][0] == 0) {
                for (int j = 0; j < A[0].length; j++) {
                    A[i][j] = A[i][j] == 0 ? 1 : 0;
                }
            }
        }

        // 反转每一列，使尽可能多的高位为1
        for (int j = 1; j < A[0].length; j++) {
            // 先统计当前列有多少个0，是否超过一半
            int zeros = 0;
            for (int i = 0; i < A.length; i++) {
                if (A[i][j] == 0) zeros++;
            }
            // 如果超过一半则反转
            if (zeros > A.length / 2) {
                for (int i = 0; i < A.length; i++) {
                    A[i][j] = A[i][j] == 0 ? 1 : 0;
                }
            }
        }

        int res = 0;
        for (int i = 0; i < A.length; i++) {
            int cur = 0;
            for (int j = 0; j < A[0].length; j++) {
                cur <<= 1;
                cur |= A[i][j];
            }
            
            res += cur;
        }
        return res;
    }
}
```

但是这样效率比较低，实际上**列不需要真正反转，只需要记录每一列反转或者不反转对结果的影响**  

```
class Solution {
    public int matrixScore(int[][] A) {
        if (A.length == 0 || A[0].length == 0) return 0;

        // 反转每一行，使最高位为1
        for (int i = 0; i < A.length; i++) {
            if (A[i][0] == 0) {
                for (int j = 0; j < A[0].length; j++) {
                    A[i][j] = A[i][j] == 0 ? 1 : 0;
                }
            }
        }   

        int res = 0;
        for (int j = 0; j < A[0].length; j++) {
            // 先统计当前列有多少个1，是否超过一半
            int ones = 0;
            for (int i = 0; i < A.length; i++) {
                ones += A[i][j];
            }
            // 不反转，直接记录当前列的1对结果的贡献
            res += Math.max(ones, A.length - ones) * (1 << (A[0].length - j - 1));
        }
        return res;
    }
}
```



## 单调栈

### 496. 下一个更大元素 I

> https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/

单调栈，标准题。单调栈的通解看上面这个题解  

```
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums1.length; i++) {
            map.put(nums1[i], i);
        }
        
        // 里面不存元素，存元素的角标，这样泛化性比较强
        Deque<Integer> stack = new ArrayDeque<>();
        // 倒序访问，这样弹栈才是正序
        for (int i = nums2.length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums2[stack.peek()] <= nums2[i]) {
                stack.pop();
            }
            if (map.containsKey(nums2[i])) {
                res[map.get(nums2[i])] = stack.isEmpty() ? -1 : nums2[stack.peek()];
            }
            stack.push(i);
        }
        return res;
    }
}
```



### 503. 下一个更大元素 II

循环数组的单调栈。想象成两倍长度的数组，题解还看上面那个

```
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];
        Deque<Integer> stack = new ArrayDeque<>();
        int n = nums.length;
        // 既然循环，那么更大的元素可能在左边，则在右边再拼一个数组，假装数组变成两倍长
        for (int i = n * 2 - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[stack.peek()] <= nums[i % n]) {
                stack.pop();
            }

            res[i % n] = stack.isEmpty() ? -1 : nums[stack.peek()];
            stack.push(i % n);
        }
        return res;
    }
}
```

### 1019. 链表中下一个更大节点

和496一样的，转成数组做就行

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] nextLargerNodes(ListNode head) {
        List<Integer> list = new ArrayList<>();
        while (head != null) {
            list.add(head.val);
            head = head.next;    
        }

        int[] res = new int[list.size()];
        Deque<Integer> stack = new ArrayDeque<>();

        for (int i = list.size() - 1; i >= 0; i--) {
            while (!stack.isEmpty() && list.get(stack.peek()) <= list.get(i)) {
                stack.pop();
            }

            res[i] = stack.isEmpty() ? 0 : list.get(stack.peek());
            stack.push(i);
        }
        return res;
    }
}
```

