# 数的位操作

### 7.整数反转
直接反转拼接即可，注意处理越界
```
class Solution {
    public int reverse(int x) {
        int flag = x >= 0 ? 1 : -1;
        x = flag * x;
        int res = 0;
        int base = 1;
        while (x > 0) {
            int tmp = x % 10;
            x /= 10;
            if (res > (Integer.MAX_VALUE - tmp) / 10) return 0;
            res = res * 10 + tmp;
            // System.out.println(res + " " + tmp);
        }
        return res * flag;
    }
}
```

### 9.回文数
根据上题求反转后的数，跟原数比较，相同则为回文数
```
class Solution {
    public boolean isPalindrome(int x) {
        if(x < 0)
            return false;
        int cur = 0;
        int num = x;
        while(num != 0) {
            cur = cur * 10 + num % 10;
            num /= 10;
        }
        return cur == x;
    }
}
```

### 479.最大回文数乘积
本题直接搜索会超时，看题解中的方法。  
先拿到给定位数的最大值，然后reverse一下拼在后面作为回文数结果，然后看这个拼接出的回文数能否由两个n位数相乘得出。  
```
class Solution {
    public int largestPalindrome(int n) {
        if(n == 1) return 9;
        //计算给定位数的最大值
        long max = (long)Math.pow(10,n) - 1;
        //从max - 1开始循环，原因见上文
        for(long i = max - 1; i > max / 10; i--){
            //1. 构造回文数
            String s1 = String.valueOf(i);
            long rev = Long.parseLong(s1 + new StringBuilder(s1).reverse().toString());
            //2. 检验该回文数能否由给定的数相乘得到
            for(long x = max; x * x >= rev; x --){
                if(rev % x == 0) return (int)(rev % 1337);
            }
        }
        return -1;
    }
}
```
### 231.2的幂
2的幂的特点是其二进制只有一位是1，其余都是零  
```
class Solution {
    public boolean isPowerOfTwo(int n) {
        if (n <= 0) return false;
        while (n > 0) {
            if ((n & 1) == 1 && (n >> 1) > 0) {
                return false;
            }
            n >>= 1;
        }
        return true;
    }
}
```
更简单的方法：2的幂-1的二进制一定是除了原本那个1之外其他的都是1，所以它们两个做与运算为0  
```
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}
```
### 342.4的幂
跟上题一样，4的幂二进制是奇数位为1其他都为0.比如：1 - 0001; 4 - 0100 ; 16- 00010000  
```
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) return false;
        int count = 0;
        while ((n & 1) == 0) {
            n >>= 1;
            count++;
        }
        if ((n >> 1) == 0 && count % 2 == 0) {
            return true;
        }
        return false;
    }
}
```
### 326.3的幂
3的幂转二进制没什么规律，且正负都有所以只能搜索。  
3的幂除3还是3的幂，所以代码如下  
```
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n == 0) return false;
        if (n == 1) return true;
        return (n % 3 == 0) && isPowerOfThree(n / 3);
    }
}
```
### 504.七进制数
转七进制就是一直把余数往前面添加，然后原数字除7  
```
class Solution {
    public String convertToBase7(int num) {
        int flag = 1;
        if (num == 0) return "0";
        if (num < 0) {
            flag = -1;
            num = -num;
        }
        StringBuilder sb = new StringBuilder();
        int pow = 1;
        while (num > 0) {
            sb.insert(0, num % 7);
            num /= 7;
        }
        if (flag == -1) sb.insert(0, '-');
        return sb.toString(); 
    }
}
```