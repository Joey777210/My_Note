# 分布式锁
## 前言
在多线程环境下，由于上下文的切换，数据可能出现不一致的情况或者数据被污染，我们需要保证数据安全，所以想到了加锁。  
所谓的加锁机制呢，就是当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。  
## 基于Zookeeper的分布式锁
### ZK是什么
Zookeeper是一个数据库，文件存储系统，并且有监听通知机制（观察者模式）  
它的主要应用场景有以下几个：
* 服务注册与订阅（共用节点）
* 分布式通知（监听znode）
* 服务命名（znode特性）
* 数据订阅、发布（watcher）
* 分布式锁（临时节点）
### Zookeeper是文件存储系统，那他存了什么？
**节点**  
* 持久化节点（zk断开节点还在）
* 持久化顺序编号目录节点
* 临时目录节点（客户端断开后节点就删除了）
* 临时目录编号目录节点
ZK就是基于节点去实现分布式锁的  

###  zk创建分布式锁
zk节点具有**唯一性**，让并发的线程先去加锁时创建同样的节点，创建成功的第一个返回true，他就可以继续下面的并发操作。而后续的节点全部都会创建节点失败，也就是加锁失败
### 释放锁
删除节点即释放锁，然后再通知其他线程过来加锁。  
其他服务可以利用死循环，不断尝试加锁，直到成功，**伪装一个其他线程阻塞的效果**。  
其他服务可以监听节点的删除事件，来知晓释放锁的消息。  
### 避免死锁
加锁成功后，机器宕机了，节点是不是就不能删除了？  
利用临时节点，客户端连接已断开，别的服务就可以监听到节点的变化。  
### 羊群效应
监听机制会导致一个问题，所有服务都去监听一个节点。假如服务特别多，节点的释放也会通知所有服务器，这对服务器是很大的一个挑战，一个释放的消息，就好像一个牧羊犬进入了羊群，大家都四散而开，随时可能干掉机器，会占用服务资源，网络带宽等等。这就是羊群效应  
** 利用顺序临时节点**，后面再看。。 来不及了  
和之前监听一个永久节点的区别就在于，这里每个节点只监听了自己的前一个节点，释放当然也是一个个释放下去，就不会出现羊群效应了。  
### 缺点
* ZK性能没有Redis那么高，因为每次创建锁和释放锁都要动态创建、销毁瞬时节点来实现锁功能  
* ZK中创建和删除节点只能通过Leader服务器来执行，然后同步到Follower机器上
* 使用Zookeeper也有可能带来并发问题，只是并不常见而已。由于网络抖动，客户端可ZK集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这时候其他客户端就可以获取到分布式锁了。这时候就有两个服务认为自己获取到了锁。
	但这个问题不常见，是因为ZK有重试机制，一旦ZK集群检测不到客户端的心跳，就会重试。  
Redis分布式锁是一个更好的实现。  
## 基于Redis的分布式锁
两个命令
```
SETNX key value
```
如果set成功则返回1，key存在了返回0  
```
SETEX key seconds value
```
key生存时间设为seconds，如果key存在，setex命令将覆写旧值。setex是一个**原子性**操作。  
这两个命令是实现分布式锁的关键。
### setex
设置一个过期时间，就算持锁线程挂了，也会在失效时间到达时释放锁。  
### 加锁

```
SET lock_key random_value NX PX 5000
```
* random_value 是客户端生成的唯一的字符串。
* NX 代表只在键不存在时，才对键进行设置操作。
* PX 5000 设置键的过期时间为5000毫秒。
循环加锁，加锁失败就睡眠一段时间，然后再检查一下
### 解锁
UUID拼装作为锁的Key，避免A加的锁被B解了。  
利用LUA的原子性，写一段脚本，判断目前加锁的Key和我们的参数是否相等，如果是就删除key，返回1，否则返回0  

### 可重入锁
UUID比较相同，则可重入。  
方案一： setex value中存储锁的重入次数，如果锁存在，且key中的UUID跟本线程的UUID一样，那么让value中存储的重入次数增加1

## 基于MySQL的分布式锁