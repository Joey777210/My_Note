# 缓存

### 博客记录

https://zhuanlan.zhihu.com/p/261413349  
https://mp.weixin.qq.com/s/6J2K2k4Db_20eGU6xGYVTw  
https://github.com/AobingJava/JavaFamily  

https://github.com/Dikea/awesome-job#Java  

## 缓存雪崩
目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。  

举个简单的例子：如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是**数据库立马又被新的流量给打死了**。这就是我理解的缓存雪崩。  
**同一时间大面积失效**，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果打挂的是一个用户服务的库，那其他依赖他的库所有的接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你能重启的时候，用户早就睡觉去了，并且对你的产品失去了信心，什么垃圾产品。  

### 解决方案
1. 处理缓存雪崩简单，在批量往Redis存数据的时候，**把每个Key的失效时间都加个随机值就好了**，这样可以**保证数据不会在同一时间大面积失效**，我相信，Redis这点流量还是顶得住的。  
2. **如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题**
3. **设置热点数据永远不过期，有更新操作就更新缓存就好了**（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间）
## 缓存穿透/击穿
* **缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求**，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，**攻击会导致数据库压力过大，严重会击垮数据库。**  
* 缓存击穿，跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是**缓存击穿是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个*Key在失效的瞬间*，持续的大并发就穿破缓存，直接请求数据库**，就像在一个完好无损的桶上凿开了一个洞。  
### 缓存穿透解决方案
1. 缓存穿透我会在**接口层增加校验**，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
** 不相信调用你的人，你不知道他会传什么参数给你。**  
比如接口是分页查询的，但是你没对分页参数的大小做限制，调用的人万一一口气查 Integer.MAX_VALUE 一次请求就要你几秒，多几个并发你不就挂了么？是公司同事调用还好大不了发现了改掉，但是如果是黑客或者竞争对手呢？在你双十一当天就调你这个接口会发生什么，就不用我说了吧。  
2. 缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对**写为null**
3. 网关层Nginx有配置项，可以让运维对单个IP每秒访问次数**超出阈值的IP都拉黑**。
4. **布隆过滤器**，利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

### 缓存击穿解决方案
1. **设置热点数据永不过期**
2. 缓存失效重新取数据时，加**互斥锁**

## Redis高可用
一般避免以上情况发生我们从三个时间段去分析下：  

事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。  

事中：本地 ehcache 缓存 + Hystrix 限流+降级，避免MySQL被打死。  

事后：Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。  

