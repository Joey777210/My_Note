## 订单重跑
首先分页查询从数据库里捞数据，通过MQ发出去，异步化。监听线程拿到数据之后进行二次包装，再通过同步转异步的接口去调用analyse

## 风控订单中间层risk-Service
#### 缓存
风控客户端编号、产品信息、场景信息等metadata，使用redis做缓存，缓存存活时间600秒
#### 幂等
幂等要求每一个请求在多次请求时都会得到同样的结果，不会多次重复触发同一个请求导致多次付款问题。  
每一个风控request过来，都用bizId+clientCode（全局唯一）作为key，请求分布式锁，如果锁没请求到，说明已经在执行了，直接返回。如果请求到了，去request库中查询bizId和clientCode，如果存在说明这个request已经请求过了。如果没有，将request保存到库中，构建其他风控信息，然后在finally块中解锁。  
接下来在风控订单过程中upt库之前都要先检查库中的订单是否是终态。如果已经是终态那么就不能更新，也不需要继续往下走流程。  
另外，其实前面已经保证了幂等，不过为了保证安全，每次更新数据库中的请求状态或订单状态都要乐观锁CAS更新。  
这里为了实现CAS，在表中设置了Version字段，Version相同才能更新。当Version过期就更新新的version来upt数据库，如果数据已经到达终态就停止自旋。自旋次数设置了11次作为默认值。
#### 异步
请求引擎之后，引擎先同步返回“分析中”的结果，然后分析结束之后再通过MQ异步返回最终结果。  
同步rpc接口异步化。通过Async注解，让同步调用的接口通过线程池异步调用。  
