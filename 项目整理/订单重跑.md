## 订单重跑
首先分页查询从数据库里捞数据，通过MQ发出去，异步化。监听线程拿到数据之后进行二次包装，再通过同步转异步的接口去调用analyse  

**这里为什么要用MQ异步？**  

第一方面的原因，异步无需等待IO，查库也不需要等待调用的execute返回，让两部分解耦掉  

第二方面的原因，重跑和预警都是定时任务，可能量很大，而且定时任务很密集的话，会给数据库和接口很大压力。所以用MQ，**削峰+解耦**，给数据库减压



## 风控订单中间层risk-Service承上启下
#### 缓存
风控客户端编号、产品信息、场景信息等metadata，使用redis做缓存，缓存存活时间600秒  

更新缓存的策略：先更新数据表，成功后让缓存失效  

https://coolshell.cn/articles/17416.html

#### 幂等
幂等要求每一个请求在多次请求时都会得到同样的结果，不会多次重复触发同一个请求导致多次付款问题。  

每一个风控request过来，都用bizId+clientCode（全局唯一）作为key，请求分布式锁，如果锁没请求到，说明已经在执行了，直接返回，实现幂等控制（这里锁范围中做的事：将Request的bizId和ClientCode从请求信息中取出来，bizId和Client code在业务方是不会变的，然后拿去查库，如果不存在，则说明是第一次请求，并插入request表，如果存在，则做幂等控制直接返回）。如果请求到了，去request库中查询bizId和clientCode，如果存在说明这个request已经请求过了。如果没有，将request保存到库中，构建其他风控信息，然后在finally块中解锁。  

接下来在风控订单过程中upt库之前都要先检查库中的订单是否是终态。如果已经是终态那么就不能更新，也不需要继续往下走流程。  

另外，其实前面已经保证了幂等，不过为了保证安全，每次更新数据库中的请求状态或订单状态都要乐观锁CAS更新。  

这里为了实现CAS，在表中设置了Version字段，Version相同才能更新。当Version过期就更新新的version来upt数据库，如果数据已经到达终态就停止自旋。自旋次数设置了11次作为默认值。  

**这里为什么要分布式锁，先查后存，而不是直接存，让数据库把冲突异常抛出来呢？**  

因为如果直接insert，那么检测到冲突键时，会对数据库中这条冲突数据加**Next-key lock**，影响后续其他事务的提交。所以先加分布式锁，如果枷锁成功，说明目前没有这个订单正在运行，然后查询，说明这个历史订单，查询不会加锁，而是MVCC快照读；如果查不到，再进行Insert，这时Insert不会有冲突数据，会加隐式锁，隐式锁不是锁，只会在其他事务竞争锁的时候才生成锁结构。这样**减轻数据库压力，让数据库做尽可能少的操作**  

**为什么要用乐观锁？**  

利用乐观锁数据对比的方式将订单状态刷盘，不直接刷盘的原因是，保障系统安全，多加一层防护。加Version字段防止ABA现象  

#### 异步
请求引擎之后，引擎先同步返回“分析中”的结果，然后分析结束之后再通过MQ异步返回最终结果。  

同步rpc接口异步化。通过Async注解，让同步调用的接口通过线程池异步调用。    

**FutureTask**  

#### 分布式锁的讨论
我们使用基于缓存的分布式锁，如果量大可以对id分段加锁。  

量如果特别大，亿级，Redis可能会挂，就要mysql做水平分表，把表分小之后做悲观锁，使用select for update。但还是一个分段加锁的思路，不过要把分布式锁换为基于数据库的悲观锁。  

总之如果量特别大，就不能信任缓存，只能信任数据库，做分库分表，表切的很小之后加悲观锁。  