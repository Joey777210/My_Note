# 集合框架

## 概述
![集合](./Pics/集合.png)  

Java集合主要由两大接口派生：**Collection**和**Map**  
Collection存放单一元素  
Map存放Key-Value键值对  

## Collection
Collection中的API无非四种:增删改查，其中没有改，实际就是增删改，另外还有其他API，包括isEmpty()/size()/toArray()  

### List
List最大的特点就是**有序，可重复**。List的实现有ArrayList、LinkedList、Vector三种，其中Vector已经不推荐使用。  
|功能|方法|ArrayList|LinkedList|
|----|----|----|----|
|增|add(E e)|O(1)|O(1)|
|增|add(int index, E e)|O(n)|O(n)|
|删|remove(int index)|O(n)|O(n)|
|删|remove(E e)|O(n)|O(n)|
|改|set(int index, E e)|O(1)|O(n)|
|查|get(int index)|O(1)|O(n)|
ArrayList是用数组实现的，**可以随机访问**，可以用O(1)的复杂度拿到任何位置的数，而链表做不到，只能从头开始遍历。所以在改和查这两个操作，ArrayList更快。  

* 改、查操作多选ArrayList
* 增删在尾部选ArrayList
* 其他情况下，如果时间复杂度一样，优先使用ArrayList，因为overhead更小，内存使用更有效率

* Vector
	数组实现，线程安全。但已经被弃用，弃用的原因就是加了太多synchronized，效率低！
	另外和ArrayList的另外一个区别就是，ArrayList扩容时扩为原本的1.5倍；而Vector扩容时扩为原本的2倍  
* Stack继承自Vector，那自然也不推荐使用了。如果要实现Stack的语义，就使用**ArrayDeque**吧！


### Queue Deque

队列一般都是先进先出FIFO，但有个例外，就是PriorityQueue，也叫heap，并不按照进去的顺序出来，而是按照规定的优先级排序出来，并且它操作不是O(1)的。  
Queue有两组API，功能基本一样，区别在于越界等情况会不会抛异常。  
|功能|抛异常|返回值|
|----|----|----|
|增|add(e)|offer(e)|
|删|remove()|poll()|
|查|element()|peek()|
方法都是O(1)
#### Deque
Double End Queue的缩写，双端队列，两端都可以进出，则有两端API，每一端都有两组，一组抛异常，一组返回特殊值。  

它们的实现类有三个：LinkedList、ArrayDeque、PriorityQueue
* 如果想实现【普通队列-先进先出】就是用LinkedList或者ArrayDeque
* 如果想实现【优先队列】就使用PriorityQueue
* 如果想实现【栈】的语义，就使用ArrayDeque

ArrayList和LinkedList性能对比：
* 头部插入：LinkedList快于ArrayList
* 中间插入：ArrayList快于LinkedList。明明链表插入不需要复制，而数组中间插入需要复制，为什么链表却比数组慢呢？这是因为：**LinkedList在中段插入时，需要先判断插入位置离哪一端更近，然后从这端开始遍历找到插入位置，就有了一个for循环；而ArrayList需要遍历调用Native的数组复制操作，也是一个C语言的遍历for循环，这两个for循环C语言的更快**  
* 尾部插入：ArrayList略快一点点，因为LinkedList有额外的new Node和变换指针的开销。  

ArrayDeque和LinkedList性能对比：
* ArrayDeque使用数组实现的循环队列，https://www.cnblogs.com/wxd0108/p/7366234.html ，ArrayDeque在大多数情况下的增删改查都比LinkedList要快，除了一种情况，就是在遍历LinkedList的过程中，删除掉遍历到的这个元素。  
* 因为循环队列，所以ArrayDeque在头尾操作都比LinkedList要快。  
* ArrayDeque不能存放null，而LinkedList可以
* 什么使用LinkedList？Java6之前，还没有ArrayDeque

### Set
Set的特点和List相反，无序，不重复。  
Set常用的实现类有三个：
* HashSet：采用HashMap的Key来存数据，无序，基本操作都是O(1)
* LinkedHashSet：HashSet + LinkedList的结，既拥有了O(1)的复杂度，又保留了插入的顺序
* TreeSet：红黑树，有序，可以用自然顺序或者自定义比较器，但查询速度没有HashSet快。

每个Set底层其实都是对应的Map，Key上放了值，Value上放了一个PRESENT，是一个静态的Object用来占位。

## Map
![Map](./Pics/Map.png)  
Map独立于Collection之外，常用的实现类有HashMap、HashTable、TreeMap、ConcurrentHashMap、LinkedHashMap、weakHashMap

### HashMap
采用位桶和链表/红黑树存储，线程不安全。

### Hashtable
**线程安全，各个方法上添加了synchronize关键字**。但是现在已经不再推荐使用HashTable了，因为现在有了ConcurrentHashMap这个专门用于多线程场景下的map实现类，其大大优化了多线程下的性能。  

### ConcurrentHashMap
jdk1.8之前采用分段锁，1.8开始采用CAS + syncronized

### TreeMap
红黑树组织的Map，查找O(logN)，节点有序。

### LinkedHashMap
有序的Map

### weakHashMap
弱键，Key和Value都可以是null，而且其Map中如果这个Key值指向的对象没被使用，此时触发了GC，该对象就会被回收掉的。其原理主要是使用的WeakReference和ReferenceQueue实现的，其key就是weakReference，而ReferenceQueue中保存了被回收的 Key-Value。  

## 参考
https://mp.weixin.qq.com/s/bVOSat47L0Hskfx9akAN6Q  
