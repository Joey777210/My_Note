# 计算机网络
## 基本概念
五层体系结构由**应用层，运输层，网络层（网际层），数据链路层，物理层**组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。
## 物理层
物理层主要做的事情是**透明的传送比特流**。  
**物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。** 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。  
### 常用的信道复用
1. 频分复用(FDM)：所有用户在同样的时间占用不同的带宽资源
2. 时分复用(TDM)：所有用户在不同的时间占用同样的频带宽度
3. 统计时分复用(Statistic TDM)：改进的时分复用，能够明显提高信道的利用率。
4. 码分复用(CDM)：用户使用经过特殊挑选的特殊码型，因此用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。
5. 波分复用(WDM)：光的频分复用
## 数据链路层
* 循环冗余检验CRC：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。
* 帧(Frame)：一个数据链路层的传送带元，由一个数据链路层首部和其携带的封包所组成协议数据单元
* MTU(Maximum Transfer Unit)：最大传送单元。帧的数据部分的长度上限
* 误码率BER：在一段时间内，传输错误的比特占所传输比特总数的比率
* PPP(Point-to-Point Protocal)：点对点协议，即用户和ISP通信时所采用的数据链路层协议
* MAC地址：或称为物理地址、硬件地址，用来定义网络设备的位置。**在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。**因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。
* 网桥：用于数据链路层实现中继，连接两个或多个局域网的网络互联设备
* 交换机：实质是一个多接口的网桥
### 以太网的数据链路层
* 以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做
* 以太网采用的协议是**具有冲突检测的载波监听多点接入 CSMA/CD**。协议的特点是：发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照**退避算法**等待一段随机时间后再次发送。 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道
* 以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。
* 使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）
## 网络层
网络层主要作用是**实现主机与主机之间的通信，也叫点对点**  
似乎数据链路层也是做的这件事？但他们之间是有区分的：** IP 的作用是主机之间通信用的，而 MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**  
### IP协议的基础知识
* 在TCP/IP通信时，每个主机都需要配置正确的IP地址，否则无法正常通信。  
IPv4地址由32位二进制表示；而为了人们记忆方便，采用点分十进制来表示，将32位二进制分为8位一组，总共4组，以‘.’隔开，每组转为0~255之间的十进制。  
* IP地址的最大值位2^32，约为43忆。采用可以更换IP地址的NAT技术，使得能够连接到互联网的设备远远超过43亿台。  
### IP地址的分类
IP地址被分为A、B、C、D、E五类，如下图  
![IP地址分类](./Pics/IP地址分类.jpg)  
黄色部分为分类号，用来区分IP地址的类别。  
#### 什么是A B C类地址？
ABC类地址主要分为两部分，**网络号和主机号**，根据二进制计算可以得到三类IP地址的取值范围和最大主机数。  
![IP地址最大主机数](./Pics/IP地址最大主机数.jpg)  
最大主机数计算方式就是2的主机数位数次方 - 2，这里的减2，减掉的是主机号全1的用于指定某个网络的地址和主机号全0的用于广播的地址  
#### 什么是D E类地址？
而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。  
多播用于**将包发送给特定组的所有主机**，可以穿透路由  
#### IP地址分类的优缺点
* 优点：通过第几位是0/1可以快速判断出地址分类，然后就轻易知道了网络地址和主机地址。  
* 缺点：
	1. 同一网络下没有地址层次
	2. 不能很好的与现实的网络规模匹配
为了解决这些缺点，发明了CIDR无分类地址
### 无分类地址CIDR
32比特的IP地址被分为两部分，前面是网络号，后面是主机号，那么怎么划分二者呢？通过在后面添加一个`/x`，前x位属于网络号，x的范围是0~32  
比如：10.100.122.2/24，这种表示形式就是CIDR，前24位是网络号，剩余8位是主机号  
除此之外还有另一种划分网络号与主机号的形式，那就是**子网掩码**，掩码的意思就是掩盖掉主机号，剩余的就是网络号，将子网掩码和IP地址按位做AND操作，即可得到网络号  
### 为什么要分开网络号和主机号？
因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果相同，则表示接收方在本网络上，可以把数据包直接发送到目标主机。  
路由器寻址过程中，也是通过这样的方式找到对应网络号，进而把数据包转发进目标网络中的  
### 网络层后续部分先不看

### DNS
DNS域名解析可以将域名网址自动转换为具体的IP地址
#### 域名的层级关系
DNS中的域名都用句点来分割，例如`www.server.com`，句点代表了不同层次之间的界限  
在域名中，越靠右的位置表示其层级越高。根域是在最顶层，它的下一层是com顶级域，在下面是server.com  
所以域名的层级关系类似一个树状结构：  
* 根DNS服务器
* 顶级DNS服务器(com)
* 权威DNS服务器(server.com)
根域的DNS服务器信息保存在互联网中所有DNS服务器中，这样任何DNS服务器就都可以找到并访问根域DNS服务器了。  
因此，客户端只要找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，再一路顺藤摸瓜找到位于下层的某台目标DNS服务器
#### DNS解析过程
1. 在浏览器中输入www . qq .com 域名，操作系统会**先检查自己本地的hosts文件是否有这个网址映射关系**，如果有，就先调用这个IP地址映射，完成域名解析。
2. 如果hosts里没有这个域名的映射，则**查找本地DNS解析器缓存**，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
3. 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会**找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器**，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
4. 如果本地DNS服务器本地区域文件与缓存解析都失效，则**根据本地DNS服务器的设置（是否设置转发器）进行查询  
	如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(http://qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找http://qq.com域服务器，重复上面的动作，进行查询，直至找到www  . qq  .com主机。**
	**如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。**
	
* **从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。**

____________________________________
以下是另一个解释，写的也很好  

1. 浏览器缓存　　
	当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；　　
2. 系统缓存　　
	当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；　　
3. 路由器缓存　　
	当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；　　
4. ISP（互联网服务提供商）DNS缓存　　
	当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；　　
5. 根域名服务器　　
	当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；　　
6. 顶级域名服务器　　
	顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；　　
7. 主域名服务器　　
	主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；　　
8. 保存结果至缓存　　
	本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。
### ARP

### DHCP

### NAT

### ICMP

### IGMP

## 运输层/传输层
详细看小林coding的pdf
### TCP
#### TCP基本认识
![tcp头部](./Pics/tcp头部.jpg)
彩色部分是我们要特殊注意的  
* 序列号：在建立连接时，计算机生成随机数作为其初始值，通过SYN传给接收端，每发送一次数据，就**累加一次该数据字节数的大小**，**用来解决网络包乱序问题**
* 确认应答号：下一次**期望**收到的数据的序列号，发送端收到这个确认应答以后**可以认为在这个序号以前的数据都已经被正常接收**。**用来解决不丢包的问题**。
* 控制位
	1. ACK：该位为`1`时，确认应答字段有效。TCP规定储了最初建立连接时的SYN包以外，该位必须设置为1
	2. RST：该位为`1`时，表示TCP连接中出现异常必须强制断开连接
	3. SYN：该位为`1`时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定
	4. FIN：该位为`1`时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换`FIN`位为1的TCP段
#### 为什么需要TCP？
IP层是不可靠的，它**不保证网络包交付、按序交付、数据完整性**  
要保障网络数据包的可靠性，就需要传输层的TCP来负责。  
因为TCP是工作的**传输层**的**可靠**数据传输服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余、按序的**  
#### 什么是TCP？
TCP是**面向连接的、可靠的、基于字节流**的传输层通信协议  
* 面向连接：**一对一**才能连接，不能像UDP，一个主机同时向多个主机发送消息，一对多是无法做到的
* 可靠的：无论网络链路中出现了怎盐大哥链路变化，TCP都可以保证一个报文一定能够到达接收端
* 字节流：消息**没有边界**的，所以无论我们消息有多大，都可以传输。并且消息是**有序的**，当前一个消息没有收到的时候，即使先收到了后面的消息，也不能给应用层去处理，同时**重复**的报文会自动丢弃
#### 什么是TCP连接
**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接**  
建立一个连接需要客户端与服务器就以上三个信息达成共识  
* Socket：由IP地址和端口号组成
* 序列号：用来解决乱序问题
* 窗口大小：用来做流量控制
#### 如何唯一确定一个TCP连接？
**TCP四元组**  
* 源IP地址
* 源端口
* 目的IP地址
* 目的端口
源地址和目的地址字段是在IP头部中，作用是通过IP协议发送报文给对方主机  
源端口和目的端口是在TCP头部中，作用是告诉TCP协议应该把报文发给哪个进程  
#### 有一个IP的服务器监听了一个端口，它的TCP最大连接数是多少
服务器通常固定监听某个本地端口，等待客户端的连接请求。  
因此**客户端IP和端口是可变的**，其理论值计算公式如下：
**最大TCP连接数 = 客户端IP数 × 客户端的端口数**
* 对于IPv4，客户端IP数最多为2^32，客户端端口数最多为2^16。也就是说**服务器单机最大TCP连接数约为2^48**  
当然了，服务器最大并发TCP连接数远远不能达到理论上限  
* 文件描述符限制：Socket都是以文件形式打开的，所以要通过ulimit配置文件描述符的数目
* 内存限制：每个TCP连接都要占用一定内存，而内存是有限的  
#### TCP和UDP的区别？分别的应用场景？
* UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务
* UDP协议非常简单，头部只有8个字节(64位)，UDP头部格式如下
![udp头部](./Pics/udp头部.jpg)  
* 目标和源端口：告诉UDP协议应该把报文发给哪个进程
* 包长度：保存了UDP首部长度和数据长度之和
* 校验和：为了提供可靠的UDP首部和数据而设计
**区别**
1. 连接
	TCP：面向连接
	UDP：不需要建立连接
2. 服务对象
	TCP：一对一的两点服务
	UDP：一对一、一对多、多对多交互通信
3. 可靠性
	TCP：可靠交付，数据无差错、不丢失、不重复、按序到达
	UDP：尽最大努力交付，不保证可靠
4. 拥塞控制、流量控制
	TCP：有拥塞控制和流量控制，保证数据传输安全性
	UDP：没有，即使网络非常拥堵，也不会影响UDP的发送速率
5. 首部开销
	TCP首部长度较长，会有一定开销，没有”选项“字段时是20个字节，使用了会变得更长
	UDP：8个字节，固定不变，开销较小
6. 传输方式
	TCP：流式传输，没有边界，但保证顺序和可靠
	UDP：一个包一个包的发送，有边界，可能会丢包和乱序
7. 分片不同
	TCP：数据大小如果大于MSS大小，则会在传输层进行分片，目标主机收到后，同样在传输层组装TCP数据包。如果中途丢失了一个分片，只需要传输丢失的这个分片
	UDP：如果数据大小大于MTU大小，则会在IP层分片。目标主机收到后，在IP层组装完数据，接着再传给传输层，但如果中间丢了一个分片，需要**重传所有数据包**。这样效率很差，所以通常UDP报文应小于MTU
**应用场景**
* 由于TCP面向连接，能保证数据的可靠交付，因此经常用于：
	FTP文件传输
	HTTP/HTTPS
* 由于UDP无连接，随时发送数据，再加上UDP本身处理简单又搞笑，因此经常用于：
	包总量较少的通信，如DNS、SNMP等
	视频、音频等多媒体通信
	广播通信
#### 为什么UDP首部没有首部长度，而TCP有呢？
**TCP有可变长的选项字段，而UDP首部长度不会变化**
#### 为什么UDP头部有包长度字段，而TCP没有
TCP数据长度 = IP总长度 - IP首部长度 - TCP首部长度  
其中IP总长度和IP首部长度在IP首部里已知，TCP首部长度在TCP首部中已知，所以就可以求得TCP数据的长度。  
UDP也可以通过同样的方式计算，但有一个问题，**为了网络设备硬件设计和处理方便，首部长度需要是4字节的整数倍**，如果去掉UDP包长度，那么UDP首部就不是4字节的整数倍了，可能是为了补全4的整数倍才加了一个包长度的冗余字段。  
### TCP连接建立
使用TCP前必须先建立连接，建立连接通过**三次握手**  
![三次握手](./Pics/三次握手.jpg)  
1. 一开始，客户端和服务端都处于`CLOSED`状态。第一步服务端主动监听某个端口，处于`LISRTEN`状态
2. 第一次握手：客户端随机初始化序号(client_isn)，把它放入TCP首部的序列号字段中，同时SYN置为1，表示SYN报文.接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，客户端处于`SYN-SENT`状态
![发送SYN](./Pics/发送SYN.jpg)  
3. 第二次握手：客户端收到SYN报文后，首先服务端初始花自己的序号(server_isn)，将此序号填入TCP首部序列号字段，其次把TCP首部的确认应答号字段填入`client_isn + 1`，接着把SYN和ACK置为1。最后报文发送给客户端，该报文也不包含应用层数据，之后服务端处于`SYN-RCVD`字段  
![第二个报文SYN+ACK](./Pics/第二个报文SYN+ACK.jpg)  
4. 第三次握手：客户端收到服务端报文后，向服务端回应最后一个应答报文，首先将应答报文TCP首部ACK标志位设置为1，其次确认应答号字段填入`server_isn + 1`，最后把报文发送给服务端，这次报文**可以携带客户到服务器的数据**，之后客户端处于`ESTABLISHED`状态
![第三个报文ACK](./Pics/第三个报文ACK.jpg)  
5. 服务端收到客户端的应答报文，进入`ESTABLISHED`状态，TCP连接建立成功
**上面过程可以发现，三次握手是可以携带数据，其中前两次不可以携带数据**  
#### 如果在Linux系统中查看TCP状态？
通过`netstat -napt`命令查看、
#### 为什么建立TCP连接要三次握手？不是两次、四次？
前面我们知道了**什么是TCP连接：用于保证可靠性和流量控制维护了某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接**  
所以**为什么三次握手建立TCP连接，其实本质问题是为什么三次握手才能初始化Socket、序列号和窗口大小**  
接下来从三个方面分析：
1. 三次握手才可以组织重复历史连接的初始化（主要原因）
2. 三次握手才可以同步双方的初始序列号
3. 三次握手才可以避免浪费资源
##### 原因一：避免历史连接
三次握手的**首要原因时为了防止旧的重复连接初始化造成混乱**  
![原因1](./Pics/三次握手原因1.jpg)  
客户端连续发送多次SYN建立连接的报文，在网络拥堵情况下：
* 一个旧SYN报文比最新的SYN报文早到达了服务端
* 那么此时服务端会回一个SYN+ACK报文给客户端
* 客户端收到后，根据自身上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送RST报文给服务端中止这次连接  
</br>
**如果是两次握手，就不能判断当前连接是否是历史连接，三次握手则可以在客户端准备发送第三次报文时，客户端有足够的上下文判断当前连接是否是历史连接。**  
* 如果是历史连接（序列号过期），则第三次握手发送的报文是RST，以种植历史连接
* 如果不是历史连接，第三次握手发送的报文时ACK，建立连接
**所以TCP使用三次握手建立连接的最主要原因是防止历史连接初始化了连接**  
##### 原因二：同步双方初始序列号
TCP协议的通信双方，都必须维护一个**序列号**，序列号是可靠传输的一个关键因素，作用是：
* 接收方可以取处重复数据
* 接收方可以根据序列号按序接收
* 可以标识发送出去的数据包中，哪些已经被对方收到
可见，序列号占据着非常重要的作用，所以当客户端发送携带**初始序列号**的SYN报文的时候，需要服务端回一个ACK应答报文，表示客户端的SYN报文已经被服务端成功接收，那当服务端发送初始序列号给客户端的时候，也要得到客户端的应答。**这样一来一回，二来二回，（中间两个被合并在一起），才能确保双方的初始序列号能被可靠的同步**  
* 四次握手也能够可靠的同步双方的初始化序列号，但由于**二三步可以优化成一步，就做成了三次握手**；而两次握手只能保证一方的初始序列号能被对方成功接收，没办法双向保证  
##### 原因三：避免资源浪费
如果只有两次握手，客户端的SYN请求连接在网络中阻塞时，客户端没有接收到ACK报文，就会重新发送SYN，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK信号，所以每收到一个SYN就要主动建立一个连接。这会导致一个问题：  
**在两次握手的情况下，如果客户端的SYN阻塞了，重复发送多次SYN,那么服务器就会在收到请求后建立多个冗余的无效连接，造成不必要的资源浪费**
所以总结下来：
* 两次握手：无法防止历史连接建立，会造成双方资源浪费，也无法可靠的同步双方序列号
* 四次握手：三次握手就已经理论上最少可靠连接建立，不需要使用更多的通信次数
#### 为什么客户端和服务端的初始序列号isn不相同？
如果一个失效的连接被重用，但是该旧连接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨该报文是否是历史保温，如果历史报文被新的连接接收，就会产生数据错乱。  
所以**每次建立连接前重新初始化一个序列号主要是为了通信双方能够根据序列号将不属于本次连接的报文丢弃**  
另一方面为了**安全性，防止黑客伪造相同序列号的TCP报文被对方接收**  
#### 初始序列号isn是如何随机产生的？
**基于时钟**，每4毫秒+1，转一圈要4.55小时。  
ISN = M + F(localhost, localport, remotehost, remoteport)  
* M是一个计时器，每隔4毫秒加1
* F是一个hash算法，根据localhost, localport, remotehost, remoteport生成一个随机值。要保证该hash不能被外界轻易推算，MD5是一个较好的选择。

#### 既然IP层会分片，为什么TCP层还需要MSS呢？
![MSS](./Pics/MSS.jpg)  
* MTU：一个网络包的最大长度，以太网中一般为1500字节
* MSS：除去IP和TCP头部之后，一个网络包所能容纳的TCP数据的最大长度
如果TCP的整个报文(头部+数据)交给IP层分片，当IP层有一个超过MTU的数据（TCP头部+TCP数据）要发送，那么IP层就会分片，由目标主机的IP层重新组装后交给TCP传输层。  
这看起来没问题，但存在隐患:**如果一个IP分片丢失，整个IP报文的所有分片都得重传**  
因为IP层本身没有超时重传机制，它由传输层的TCP负责超时和重传  
**当接收方发现TCP报文的某一篇丢失，则不会相应ACK给发送方，那么发送方在TCP超时后，就不得不重发整个TCP报文。由此可见，由IP层进行分片传输，非常没有效率。**   
所以，为了达到最佳的传输效能 TCP 协议**在建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。   
经过 TCP 层分片后，如果一个 TCP 分片丢失后，**进行重发时也是以 MSS 为单位，而不用重传所有的分片**，大大增加了重传的效率。
#### SYN攻击，晚些再看

#### Socket编程

### TCP是如何保证可靠的
为了实现可靠性传输，需要考虑很多事情，例如**数据的破坏、丢包、重复以及分片顺序混乱**等问题。如不能解决这些问题，也就无从谈起可靠传输。  
那么，TCP 是通过**序列号、确认应答、重发控制、连接管理以及窗口控制**等机制实现可靠性传输的。  
今天，将重点介绍 TCP 的**重传机制、滑动窗口、流量控制、拥塞控制**。
### 重传机制
TCP实现可靠传输的方式之一，是通过**序列号与确认应答**。  
![确认](./Pics/确认.jpg)  
但是实际错综复杂的网络中，并不一定能顺利正常的数据传输，**TCP针对数据包丢失的情况，采用重传机制解决**  
常见的重传机制：
* 超时重传
* 快速重传
* SACK
* D-SACK
#### 超时重传
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，**当超过指定的时间后，没有收到对方的 ACK  确认应答报文，就会重发该数据**，也就是我们常说的**超时重传**。  
TCP会在以下两种情况发生超时重传：
* 数据包丢失
* 确认应答丢失
##### 超时时间设置为多少呢？
我们先来了解以下RTT（Round-Trip Time往返时延），RTT是从网络一端传到另一端所需的时间，也就是包的往返时间。  
超时重传时间是以RTO(Retransmission Timeout 超时重传时间)表示  
* 假设重传的情况下，超时时间RTO较长，重发会很慢，丢了很久才重发，效率较低  
* RTO较短，导致可能还没丢就重发，于是重发太快，会增加网络拥塞，导致更多超时，更多的超时就导致更多的重发  
因此我们得知，**超时重传时间RTO的值应该略大于报文往返时间RTT的值**  
实际上RTT的值经常变化，所以RTO也应该是一个**动态变化的值**。  

另外，如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是**超时间隔加倍**。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为**先前值的两倍**。两次超时，就说明网络环境差，不宜频繁反复发送。**可以用快速重传机制来解决超时重发的时间等待**
#### 快速重传
快速重传，**不以时间为驱动，而是以数据驱动重传**  
![快速重传](./Pics/快速重传.jpg)  
如上图，**快速重传的工作方式是，当收到三个相同的ACK报文时，会在定时器过期之前，重传丢失的报文**  
快速重传机制只解决了一个问题，就是超时时间的问题，但是**它依然面临着另外一个问题，就是重传的时候，是重传之前的一个，还是重传所有的问题**。  
比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。由于不知道该重传哪些TCP报文，就有了SACK方法
#### SACK方法
SACK（ Selective Acknowledgment 选择性确认）  
这种方式需要**在TCP头部选项字段里加一个SACK的东西，可以将缓存的地图发送给发送方**，这样发送方就知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据**。  
![SACK](./Pics/SACK.jpg)  
如果要支持 SACK ，必须双方都要支持。在 Linux 下，可以通过 net.ipv4.tcp_sack  参数打开这个功能（Linux 2.4 后默认打开）。  
#### Duplicate SACK
D-SACK主要使用了SACK来告诉发送方，有哪些数据被重复接收了  
示例一：ACK丢包
![DSACK](./Pics/DSACK1.jpg)  
* 接收方给发送方的两个ACK都丢失了，所以发送方超时后，重传第一个数据包
* **接收方发现数据重复收到，于是回复SACK=3000~3500，告诉发送方3000~3500的数据早已被接受**，ACK都到了4000，这意味着4000之前的数据都已收到，这个SACK就代表着D-SACK  
* 这样发送方就知道了，数据没有丢，是接受方的ACK丢了
示例二：网络延时  
![DSACK](./Pics/DSACK2.jpg)  
* 数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。
* 而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；
* **所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。**
* 这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。
由此可见D-SACK有几个好处：
1. 可以从让发送方知道，是发出去的包丢了，还是接收方回应的ACK丢了
2. 可以让知道是不是发送方的数据包被网络延迟了
3. 可以知道网络中是不是把发送方的数据包给复制了、
在 Linux 下可以通过 net.ipv4.tcp_dsack  参数开启/关闭这个功能（Linux 2.4 后默认打开）
### 滑动窗口
我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。  
所以，这样的传输方式有一个缺点：**数据包的往返时间越长，通信的效率就越低**  
为了解决这个问题，TCP引入了**窗口**这个概念，即使在往返时间较长的情况下，它也不会降低网络通信的效率。  
窗口大小**是指无需等待确认应答，而可以继续发送数据的最大值**  
窗口的实现实际上是操作系统上开辟的一个缓存空间，发送方主机在等到确认应答ACK之前，必须在缓冲区中保留已发送的数据，如果按期收到确认应答，此时数据就从缓存区中清除  
* 示例：假设窗口大小为 3  个 TCP 段，那么发送方就可以「连续发送」 3  个 TCP 段，并且中途若有 ACK丢失，可以通过「下一个确认应答进行确认」。如下图：  
![滑动窗口](./Pics/滑动窗口.jpg)  
**图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫累计确认或者累计应答。**（如果没有收到600，接收方不会发送ACK700，而是继续发送ACK600，如果连续收到三次ACK600，则触发快速重传）  
#### 滑动窗口由谁决定？
TCP首部有一个字段叫Window，也就是窗口大小。  
**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**  
所以，**通常窗口的大小是由接收方的窗口大小来决定的。**发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。  
#### 发送方的滑动窗口
我们先来看看发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分，其中深蓝色方框是发送窗口，紫色方框是可用窗口：  
![发送方的滑动窗口1](./Pics/发送方的滑动窗口1.jpg)  
接下来，当发送方把数全都一下发送出去后，可用窗口的大小就为0了，表明可用窗口耗尽，在没收到ACK确认之前无法继续发送数据了。如下图  
![发送方的滑动窗口2](./Pics/发送方的滑动窗口2.jpg)  
当收到之前发送的数据32~36字节的ACK确认后，如果发送窗口的大小没有发生变化，则**滑动窗口向右滑动5个字节，因为有5个字节的数据被应答确认了**，接下来52~56字节又进入了可用窗口，也就可以发送这些数据了。如下图  
![发送方的滑动窗口3](./Pics/发送方的滑动窗口3.jpg)  
#### 发送方的四个部分在程序中是如何表示的？
TCP使用三个指针来跟踪在四个传输类别中每一个类别中的字节，其中两个指针使绝对指针（指特定的序列号），一个是相对指针（需要做偏移）  
![发送方的滑动窗口4](./Pics/发送方的滑动窗口4.jpg)  
* SND.WND：表示发送窗口的大小（大小由接收方指定）
* SND.UNA：是一个绝对指针，指向已发送但未收到确认的第一个字节的序列号，也就是#2的第一个字节
* SND.NXT：绝对指针，指向未发送但可发送范围的第一个字节的序列号，也就是#3的第一个字节  
* 指向#4的第一个字节是个相对指针，它需要SND.UNA加上SND.WND大小的偏移量，就可以指向#4的第一个字节。  
* 可用窗口大小的计算就是：可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)  
#### 接收方的滑动窗口
![接收方的滑动窗口](./Pics/接收方的滑动窗口.jpg)  
三部分：
* #1 + #2是已成功接收并确认的数据（等待应用进程读取）
* #3是未收到数据但可以接受的数据
* #4是未收到数据且不可以接收的数据
其中三个接收部分，使用两个指针划分：
* RCV.WND：表示接收窗口的大小，它会告知给发送方
* RCV.NXT：指针，指向期望从发送方发送来的i爱一个数据字节的序列号，也就是#3的第一个字节
* 指向#4的第一个字节是相对指针，它需要RCV.NXT加上RCV.WND大小的偏移量
#### 接收窗口和发送窗口的大小是相等的吗？
**并不完全相等，约等于**  
因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话**接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方**。那么这个传输过程是存在**时延**的，所以接收窗口和发送窗口是约等于的关系。
### 流量控制
